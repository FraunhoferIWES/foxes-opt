


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="">
    
    
      
        <title>scipy.spatial.distance - foxes-opt 0.5 documentation</title>
      
    
    
      
        
      
      


    
    
      
    
    
      
        
        
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
        <link rel="stylesheet" type="text/css" href="../../../_static/sphinx_immaterial_theme.03757d82676c6523d.min.css?v=d977aabd" />
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="teal" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../../index.html" title="foxes-opt 0.5 documentation" class="md-header__button md-logo" aria-label="foxes-opt 0.5 documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>
    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            foxes-opt 0.5 documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              scipy.spatial.distance
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/FraunhoferIWES/foxes-opt" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    foxes-op
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../index.html" title="foxes-opt 0.5 documentation" class="md-nav__button md-logo" aria-label="foxes-opt 0.5 documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>
    </a>
    foxes-opt 0.5 documentation
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/FraunhoferIWES/foxes-opt" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    foxes-op
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../citation.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    <span title="/citation.md (reference label)">Citation</span>
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../installation.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    <span title="/installation.md (reference label)">Installation</span>
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../parameter_files.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    <span title="/parameter_files.md (reference label)">Input parameter files</span>
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../examples.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    <span title="/examples.rst (reference label)">Examples</span>
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../api.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    <span title="/api.rst (reference label)">API</span>
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../testing.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    <span title="/testing.md (reference label)">Testing</span>
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../CHANGELOG.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    <span title="/changelog.md (reference label)">Changelog</span>
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary">
  
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset" role="main">
                
                
                  


<h1>Source code for scipy.spatial.distance</h1><div class="highlight"><pre>
<span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Distance computations (:mod:`scipy.spatial.distance`)</span>
<span class="sd">=====================================================</span>

<span class="sd">.. sectionauthor:: Damian Eads</span>

<span class="sd">Function reference</span>
<span class="sd">------------------</span>

<span class="sd">Distance matrix computation from a collection of raw observation vectors</span>
<span class="sd">stored in a rectangular array.</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :toctree: generated/</span>

<span class="sd">   pdist   -- pairwise distances between observation vectors.</span>
<span class="sd">   cdist   -- distances between two collections of observation vectors</span>
<span class="sd">   squareform -- convert distance matrix to a condensed one and vice versa</span>
<span class="sd">   directed_hausdorff -- directed Hausdorff distance between arrays</span>

<span class="sd">Predicates for checking the validity of distance matrices, both</span>
<span class="sd">condensed and redundant. Also contained in this module are functions</span>
<span class="sd">for computing the number of observations in a distance matrix.</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :toctree: generated/</span>

<span class="sd">   is_valid_dm -- checks for a valid distance matrix</span>
<span class="sd">   is_valid_y  -- checks for a valid condensed distance matrix</span>
<span class="sd">   num_obs_dm  -- # of observations in a distance matrix</span>
<span class="sd">   num_obs_y   -- # of observations in a condensed distance matrix</span>

<span class="sd">Distance functions between two numeric vectors ``u`` and ``v``. Computing</span>
<span class="sd">distances over a large collection of vectors is inefficient for these</span>
<span class="sd">functions. Use ``pdist`` for this purpose.</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :toctree: generated/</span>

<span class="sd">   braycurtis       -- the Bray-Curtis distance.</span>
<span class="sd">   canberra         -- the Canberra distance.</span>
<span class="sd">   chebyshev        -- the Chebyshev distance.</span>
<span class="sd">   cityblock        -- the Manhattan distance.</span>
<span class="sd">   correlation      -- the Correlation distance.</span>
<span class="sd">   cosine           -- the Cosine distance.</span>
<span class="sd">   euclidean        -- the Euclidean distance.</span>
<span class="sd">   jensenshannon    -- the Jensen-Shannon distance.</span>
<span class="sd">   mahalanobis      -- the Mahalanobis distance.</span>
<span class="sd">   minkowski        -- the Minkowski distance.</span>
<span class="sd">   seuclidean       -- the normalized Euclidean distance.</span>
<span class="sd">   sqeuclidean      -- the squared Euclidean distance.</span>

<span class="sd">Distance functions between two boolean vectors (representing sets) ``u`` and</span>
<span class="sd">``v``.  As in the case of numerical vectors, ``pdist`` is more efficient for</span>
<span class="sd">computing the distances between all pairs.</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :toctree: generated/</span>

<span class="sd">   dice             -- the Dice dissimilarity.</span>
<span class="sd">   hamming          -- the Hamming distance.</span>
<span class="sd">   jaccard          -- the Jaccard distance.</span>
<span class="sd">   kulczynski1      -- the Kulczynski 1 distance.</span>
<span class="sd">   rogerstanimoto   -- the Rogers-Tanimoto dissimilarity.</span>
<span class="sd">   russellrao       -- the Russell-Rao dissimilarity.</span>
<span class="sd">   sokalmichener    -- the Sokal-Michener dissimilarity.</span>
<span class="sd">   sokalsneath      -- the Sokal-Sneath dissimilarity.</span>
<span class="sd">   yule             -- the Yule dissimilarity.</span>

<span class="sd">:func:`hamming` also operates over discrete numerical vectors.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Copyright (C) Damian Eads, 2007-2008. New BSD License.</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;braycurtis&#39;</span><span class="p">,</span>
    <span class="s1">&#39;canberra&#39;</span><span class="p">,</span>
    <span class="s1">&#39;cdist&#39;</span><span class="p">,</span>
    <span class="s1">&#39;chebyshev&#39;</span><span class="p">,</span>
    <span class="s1">&#39;cityblock&#39;</span><span class="p">,</span>
    <span class="s1">&#39;correlation&#39;</span><span class="p">,</span>
    <span class="s1">&#39;cosine&#39;</span><span class="p">,</span>
    <span class="s1">&#39;dice&#39;</span><span class="p">,</span>
    <span class="s1">&#39;directed_hausdorff&#39;</span><span class="p">,</span>
    <span class="s1">&#39;euclidean&#39;</span><span class="p">,</span>
    <span class="s1">&#39;hamming&#39;</span><span class="p">,</span>
    <span class="s1">&#39;is_valid_dm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;is_valid_y&#39;</span><span class="p">,</span>
    <span class="s1">&#39;jaccard&#39;</span><span class="p">,</span>
    <span class="s1">&#39;jensenshannon&#39;</span><span class="p">,</span>
    <span class="s1">&#39;kulczynski1&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mahalanobis&#39;</span><span class="p">,</span>
    <span class="s1">&#39;minkowski&#39;</span><span class="p">,</span>
    <span class="s1">&#39;num_obs_dm&#39;</span><span class="p">,</span>
    <span class="s1">&#39;num_obs_y&#39;</span><span class="p">,</span>
    <span class="s1">&#39;pdist&#39;</span><span class="p">,</span>
    <span class="s1">&#39;rogerstanimoto&#39;</span><span class="p">,</span>
    <span class="s1">&#39;russellrao&#39;</span><span class="p">,</span>
    <span class="s1">&#39;seuclidean&#39;</span><span class="p">,</span>
    <span class="s1">&#39;sokalmichener&#39;</span><span class="p">,</span>
    <span class="s1">&#39;sokalsneath&#39;</span><span class="p">,</span>
    <span class="s1">&#39;sqeuclidean&#39;</span><span class="p">,</span>
    <span class="s1">&#39;squareform&#39;</span><span class="p">,</span>
    <span class="s1">&#39;yule&#39;</span>
<span class="p">]</span>


<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dataclasses</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy._lib._util</span><span class="w"> </span><span class="kn">import</span> <span class="n">_asarray_validated</span><span class="p">,</span> <span class="n">_transition_to_rng</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy._lib.deprecation</span><span class="w"> </span><span class="kn">import</span> <span class="n">_deprecated</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">_distance_wrap</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">_hausdorff</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..linalg</span><span class="w"> </span><span class="kn">import</span> <span class="n">norm</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..special</span><span class="w"> </span><span class="kn">import</span> <span class="n">rel_entr</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">_distance_pybind</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_copy_array_if_base_present</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Copy the array if its base points to a parent array.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">a</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_correlation_cdist_wrap</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">XA</span> <span class="o">=</span> <span class="n">XA</span> <span class="o">-</span> <span class="n">XA</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">XB</span> <span class="o">=</span> <span class="n">XB</span> <span class="o">-</span> <span class="n">XB</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_cosine_double_wrap</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_correlation_pdist_wrap</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">X2</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">X</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_cosine_double_wrap</span><span class="p">(</span><span class="n">X2</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_convert_to_type</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">out_type</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">out_type</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_nbool_correspond_all</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span> <span class="ow">and</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">not_u</span> <span class="o">=</span> <span class="o">~</span><span class="n">u</span>
        <span class="n">not_v</span> <span class="o">=</span> <span class="o">~</span><span class="n">v</span>
        <span class="n">nff</span> <span class="o">=</span> <span class="p">(</span><span class="n">not_u</span> <span class="o">&amp;</span> <span class="n">not_v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">nft</span> <span class="o">=</span> <span class="p">(</span><span class="n">not_u</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ntf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">&amp;</span> <span class="n">not_v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">not_u</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">u</span>
        <span class="n">not_v</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">v</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">not_u</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">not_u</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">u</span>
        <span class="n">nff</span> <span class="o">=</span> <span class="p">(</span><span class="n">not_u</span> <span class="o">*</span> <span class="n">not_v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">nft</span> <span class="o">=</span> <span class="p">(</span><span class="n">not_u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ntf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">not_v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">nff</span><span class="p">,</span> <span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">,</span> <span class="n">ntt</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_nbool_correspond_ft_tf</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span> <span class="ow">and</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">not_u</span> <span class="o">=</span> <span class="o">~</span><span class="n">u</span>
        <span class="n">not_v</span> <span class="o">=</span> <span class="o">~</span><span class="n">v</span>
        <span class="n">nft</span> <span class="o">=</span> <span class="p">(</span><span class="n">not_u</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ntf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">&amp;</span> <span class="n">not_v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">not_u</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">u</span>
        <span class="n">not_v</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">v</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">not_u</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">not_u</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">u</span>
        <span class="n">nft</span> <span class="o">=</span> <span class="p">(</span><span class="n">not_u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ntf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">not_v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_validate_cdist_input</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">mA</span><span class="p">,</span> <span class="n">mB</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">metric_info</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># get supported types</span>
    <span class="n">types</span> <span class="o">=</span> <span class="n">metric_info</span><span class="o">.</span><span class="n">types</span>
    <span class="c1"># choose best type</span>
    <span class="n">typ</span> <span class="o">=</span> <span class="n">types</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">XA</span><span class="o">.</span><span class="n">dtype</span><span class="p">)]</span> <span class="k">if</span> <span class="n">XA</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="n">types</span> <span class="k">else</span> <span class="n">types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># validate data</span>
    <span class="n">XA</span> <span class="o">=</span> <span class="n">_convert_to_type</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">out_type</span><span class="o">=</span><span class="n">typ</span><span class="p">)</span>
    <span class="n">XB</span> <span class="o">=</span> <span class="n">_convert_to_type</span><span class="p">(</span><span class="n">XB</span><span class="p">,</span> <span class="n">out_type</span><span class="o">=</span><span class="n">typ</span><span class="p">)</span>

    <span class="c1"># validate kwargs</span>
    <span class="n">_validate_kwargs</span> <span class="o">=</span> <span class="n">metric_info</span><span class="o">.</span><span class="n">validator</span>
    <span class="k">if</span> <span class="n">_validate_kwargs</span><span class="p">:</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_validate_kwargs</span><span class="p">((</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">),</span> <span class="n">mA</span> <span class="o">+</span> <span class="n">mB</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">kwargs</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_validate_weight_with_size</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">kwargs</span>

    <span class="k">if</span> <span class="n">w</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">w</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Weights must have same size as input vector. &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">w</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> vs. </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kwargs</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_validate_hamming_kwargs</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;double&#39;</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">w</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">w</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Weights must have same size as input vector. </span><span class="si">%d</span><span class="s2"> vs. </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kwargs</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_validate_mahalanobis_kwargs</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">VI</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;VI&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">VI</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="c1"># There are fewer observations than the dimension of</span>
            <span class="c1"># the observations.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of observations (</span><span class="si">%d</span><span class="s2">) is too &quot;</span>
                             <span class="s2">&quot;small; the covariance matrix is &quot;</span>
                             <span class="s2">&quot;singular. For observations with </span><span class="si">%d</span><span class="s2"> &quot;</span>
                             <span class="s2">&quot;dimensions, at least </span><span class="si">%d</span><span class="s2"> observations &quot;</span>
                             <span class="s2">&quot;are required.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">CV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
        <span class="n">VI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">CV</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;VI&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">VI</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kwargs</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_validate_minkowski_kwargs</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_validate_weight_with_size</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;p&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;p must be greater than 0&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">kwargs</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_validate_pdist_input</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">metric_info</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># get supported types</span>
    <span class="n">types</span> <span class="o">=</span> <span class="n">metric_info</span><span class="o">.</span><span class="n">types</span>
    <span class="c1"># choose best type</span>
    <span class="n">typ</span> <span class="o">=</span> <span class="n">types</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">)]</span> <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="n">types</span> <span class="k">else</span> <span class="n">types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># validate data</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">_convert_to_type</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">out_type</span><span class="o">=</span><span class="n">typ</span><span class="p">)</span>

    <span class="c1"># validate kwargs</span>
    <span class="n">_validate_kwargs</span> <span class="o">=</span> <span class="n">metric_info</span><span class="o">.</span><span class="n">validator</span>
    <span class="k">if</span> <span class="n">_validate_kwargs</span><span class="p">:</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_validate_kwargs</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">kwargs</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_validate_seuclidean_kwargs</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">V</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Variance vector V must &#39;</span>
                             <span class="s1">&#39;be one-dimensional.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Variance vector V must be of the same &#39;</span>
                             <span class="s1">&#39;dimension as the vectors on which the distances &#39;</span>
                             <span class="s1">&#39;are computed.&#39;</span><span class="p">)</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_convert_to_double</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kwargs</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># XXX Is order=&#39;c&#39; really necessary?</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">u</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input vector should be 1-D.&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">w</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input weights should be all non-negative&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">w</span>


<span class="nd">@_transition_to_rng</span><span class="p">(</span><span class="s1">&#39;seed&#39;</span><span class="p">,</span> <span class="n">position_num</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">replace_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">directed_hausdorff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the directed Hausdorff distance between two 2-D arrays.</span>

<span class="sd">    Distances between pairs are calculated using a Euclidean metric.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (M,N) array_like</span>
<span class="sd">        Input array with M points in N dimensions.</span>
<span class="sd">    v : (O,N) array_like</span>
<span class="sd">        Input array with O points in N dimensions.</span>
<span class="sd">    rng : int or `numpy.random.Generator` or None, optional</span>
<span class="sd">        Pseudorandom number generator state. Default is 0 so the</span>
<span class="sd">        shuffling of `u` and `v` is reproducible.</span>

<span class="sd">        If `rng` is passed by keyword, types other than `numpy.random.Generator` are</span>
<span class="sd">        passed to `numpy.random.default_rng` to instantiate a ``Generator``.</span>
<span class="sd">        If `rng` is already a ``Generator`` instance, then the provided instance is</span>
<span class="sd">        used.</span>

<span class="sd">        If this argument is passed by position or `seed` is passed by keyword,</span>
<span class="sd">        legacy behavior for the argument `seed` applies:</span>

<span class="sd">        - If `seed` is None, a new ``RandomState`` instance is used. The state is</span>
<span class="sd">          initialized using data from ``/dev/urandom`` (or the Windows analogue)</span>
<span class="sd">          if available or from the system clock otherwise.</span>
<span class="sd">        - If `seed` is an int, a new ``RandomState`` instance is used,</span>
<span class="sd">          seeded with `seed`.</span>
<span class="sd">        - If `seed` is already a ``Generator`` or ``RandomState`` instance, then</span>
<span class="sd">          that instance is used.</span>

<span class="sd">        .. versionchanged:: 1.15.0</span>
<span class="sd">            As part of the `SPEC-007 &lt;https://scientific-python.org/specs/spec-0007/&gt;`_</span>
<span class="sd">            transition from use of `numpy.random.RandomState` to</span>
<span class="sd">            `numpy.random.Generator`, this keyword was changed from `seed` to `rng`.</span>
<span class="sd">            For an interim period, both keywords will continue to work, although only</span>
<span class="sd">            one may be specified at a time. After the interim period, function calls</span>
<span class="sd">            using the `seed` keyword will emit warnings. The behavior of both `seed`</span>
<span class="sd">            and `rng` are outlined above, but only the `rng` keyword should be used in</span>
<span class="sd">            new code.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    d : double</span>
<span class="sd">        The directed Hausdorff distance between arrays `u` and `v`,</span>

<span class="sd">    index_1 : int</span>
<span class="sd">        index of point contributing to Hausdorff pair in `u`</span>

<span class="sd">    index_2 : int</span>
<span class="sd">        index of point contributing to Hausdorff pair in `v`</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        An exception is thrown if `u` and `v` do not have</span>
<span class="sd">        the same number of columns.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.spatial.procrustes : Another similarity test for two data sets</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Uses the early break technique and the random sampling approach</span>
<span class="sd">    described by [1]_. Although worst-case performance is ``O(m * o)``</span>
<span class="sd">    (as with the brute force algorithm), this is unlikely in practice</span>
<span class="sd">    as the input data would have to require the algorithm to explore</span>
<span class="sd">    every single point interaction, and after the algorithm shuffles</span>
<span class="sd">    the input points at that. The best case performance is O(m), which</span>
<span class="sd">    is satisfied by selecting an inner loop distance that is less than</span>
<span class="sd">    cmax and leads to an early break as often as possible. The authors</span>
<span class="sd">    have formally shown that the average runtime is closer to O(m).</span>

<span class="sd">    .. versionadded:: 0.19.0</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] A. A. Taha and A. Hanbury, &quot;An efficient algorithm for</span>
<span class="sd">           calculating the exact Hausdorff distance.&quot; IEEE Transactions On</span>
<span class="sd">           Pattern Analysis And Machine Intelligence, vol. 37 pp. 2153-63,</span>
<span class="sd">           2015.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Find the directed Hausdorff distance between two 2-D arrays of</span>
<span class="sd">    coordinates:</span>

<span class="sd">    &gt;&gt;&gt; from scipy.spatial.distance import directed_hausdorff</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; u = np.array([(1.0, 0.0),</span>
<span class="sd">    ...               (0.0, 1.0),</span>
<span class="sd">    ...               (-1.0, 0.0),</span>
<span class="sd">    ...               (0.0, -1.0)])</span>
<span class="sd">    &gt;&gt;&gt; v = np.array([(2.0, 0.0),</span>
<span class="sd">    ...               (0.0, 2.0),</span>
<span class="sd">    ...               (-2.0, 0.0),</span>
<span class="sd">    ...               (0.0, -4.0)])</span>

<span class="sd">    &gt;&gt;&gt; directed_hausdorff(u, v)[0]</span>
<span class="sd">    2.23606797749979</span>
<span class="sd">    &gt;&gt;&gt; directed_hausdorff(v, u)[0]</span>
<span class="sd">    3.0</span>

<span class="sd">    Find the general (symmetric) Hausdorff distance between two 2-D</span>
<span class="sd">    arrays of coordinates:</span>

<span class="sd">    &gt;&gt;&gt; max(directed_hausdorff(u, v)[0], directed_hausdorff(v, u)[0])</span>
<span class="sd">    3.0</span>

<span class="sd">    Find the indices of the points that generate the Hausdorff distance</span>
<span class="sd">    (the Hausdorff pair):</span>

<span class="sd">    &gt;&gt;&gt; directed_hausdorff(v, u)[1:]</span>
<span class="sd">    (3, 3)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;u and v need to have the same &#39;</span>
                         <span class="s1">&#39;number of columns&#39;</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_hausdorff</span><span class="o">.</span><span class="n">directed_hausdorff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span><span class="w"> </span><span class="nf">minkowski</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Minkowski distance between two 1-D arrays.</span>

<span class="sd">    The Minkowski distance between 1-D arrays `u` and `v`,</span>
<span class="sd">    is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       {\\|u-v\\|}_p = (\\sum{|u_i - v_i|^p})^{1/p}.</span>


<span class="sd">       \\left(\\sum{w_i(|(u_i - v_i)|^p)}\\right)^{1/p}.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    p : scalar</span>
<span class="sd">        The order of the norm of the difference :math:`{\\|u-v\\|}_p`. Note</span>
<span class="sd">        that for :math:`0 &lt; p &lt; 1`, the triangle inequality only holds with</span>
<span class="sd">        an additional multiplicative factor, i.e. it is only a quasi-metric.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    minkowski : double</span>
<span class="sd">        The Minkowski distance between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.minkowski([1, 0, 0], [0, 1, 0], 1)</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; distance.minkowski([1, 0, 0], [0, 1, 0], 2)</span>
<span class="sd">    1.4142135623730951</span>
<span class="sd">    &gt;&gt;&gt; distance.minkowski([1, 0, 0], [0, 1, 0], 3)</span>
<span class="sd">    1.2599210498948732</span>
<span class="sd">    &gt;&gt;&gt; distance.minkowski([1, 1, 0], [0, 1, 0], 1)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.minkowski([1, 1, 0], [0, 1, 0], 2)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.minkowski([1, 1, 0], [0, 1, 0], 3)</span>
<span class="sd">    1.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;p must be greater than 0&quot;</span><span class="p">)</span>
    <span class="n">u_v</span> <span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="n">v</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">root_w</span> <span class="o">=</span> <span class="n">w</span>
        <span class="k">elif</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># better precision and speed</span>
            <span class="n">root_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">p</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="n">root_w</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">root_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="p">)</span>
        <span class="n">u_v</span> <span class="o">=</span> <span class="n">root_w</span> <span class="o">*</span> <span class="n">u_v</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">u_v</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dist</span>


<span class="k">def</span><span class="w"> </span><span class="nf">euclidean</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Euclidean distance between two 1-D arrays.</span>

<span class="sd">    The Euclidean distance between 1-D arrays `u` and `v`, is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       {\\|u-v\\|}_2</span>

<span class="sd">       \\left(\\sum{(w_i |(u_i - v_i)|^2)}\\right)^{1/2}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    euclidean : double</span>
<span class="sd">        The Euclidean distance between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.euclidean([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    1.4142135623730951</span>
<span class="sd">    &gt;&gt;&gt; distance.euclidean([1, 1, 0], [0, 1, 0])</span>
<span class="sd">    1.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">minkowski</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">sqeuclidean</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the squared Euclidean distance between two 1-D arrays.</span>

<span class="sd">    The squared Euclidean distance between `u` and `v` is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\sum_i{w_i |u_i - v_i|^2}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sqeuclidean : double</span>
<span class="sd">        The squared Euclidean distance between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.sqeuclidean([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; distance.sqeuclidean([1, 1, 0], [0, 1, 0])</span>
<span class="sd">    1.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Preserve float dtypes, but convert everything else to np.float64</span>
    <span class="c1"># for stability.</span>
    <span class="n">utype</span><span class="p">,</span> <span class="n">vtype</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">)):</span>
        <span class="n">utype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">)):</span>
        <span class="n">vtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">utype</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">vtype</span><span class="p">)</span>
    <span class="n">u_v</span> <span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="n">v</span>
    <span class="n">u_v_w</span> <span class="o">=</span> <span class="n">u_v</span>  <span class="c1"># only want weights applied once</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">u_v_w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">u_v</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u_v</span><span class="p">,</span> <span class="n">u_v_w</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">correlation</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">centered</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the correlation distance between two 1-D arrays.</span>

<span class="sd">    The correlation distance between `u` and `v`, is</span>
<span class="sd">    defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">        1 - \\frac{(u - \\bar{u}) \\cdot (v - \\bar{v})}</span>
<span class="sd">                  {{\\|(u - \\bar{u})\\|}_2 {\\|(v - \\bar{v})\\|}_2}</span>

<span class="sd">    where :math:`\\bar{u}` is the mean of the elements of `u`</span>
<span class="sd">    and :math:`x \\cdot y` is the dot product of :math:`x` and :math:`y`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like of floats</span>
<span class="sd">        Input array.</span>

<span class="sd">        .. deprecated:: 1.15.0</span>
<span class="sd">           Complex `u` is deprecated and will raise an error in SciPy 1.17.0</span>
<span class="sd">    v : (N,) array_like of floats</span>
<span class="sd">        Input array.</span>

<span class="sd">        .. deprecated:: 1.15.0</span>
<span class="sd">           Complex `v` is deprecated and will raise an error in SciPy 1.17.0</span>
<span class="sd">    w : (N,) array_like of floats, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>
<span class="sd">    centered : bool, optional</span>
<span class="sd">        If True, `u` and `v` will be centered. Default is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    correlation : double</span>
<span class="sd">        The correlation distance between 1-D array `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Find the correlation between two arrays.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.spatial.distance import correlation</span>
<span class="sd">    &gt;&gt;&gt; correlation([1, 0, 1], [1, 1, 0])</span>
<span class="sd">    1.5</span>

<span class="sd">    Using a weighting array, the correlation can be calculated as:</span>

<span class="sd">    &gt;&gt;&gt; correlation([1, 0, 1], [1, 1, 0], w=[0.9, 0.1, 0.1])</span>
<span class="sd">    1.1</span>

<span class="sd">    If centering is not needed, the correlation can be calculated as:</span>

<span class="sd">    &gt;&gt;&gt; correlation([1, 0, 1], [1, 1, 0], centered=False)</span>
<span class="sd">    0.5</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Complex `u` and `v` are deprecated and will raise an error in &quot;</span>
            <span class="s2">&quot;SciPy 1.17.0.&quot;</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">/</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">centered</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">umu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
            <span class="n">vmu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">umu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="n">vmu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="n">umu</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">vmu</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vw</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">w</span>
        <span class="n">uw</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="n">w</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vw</span><span class="p">,</span> <span class="n">uw</span> <span class="o">=</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span>
    <span class="n">uv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">vw</span><span class="p">)</span>
    <span class="n">uu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">uw</span><span class="p">)</span>
    <span class="n">vv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">vw</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">uv</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">uu</span> <span class="o">*</span> <span class="n">vv</span><span class="p">)</span>
    <span class="c1"># Clip the result to avoid rounding error</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">cosine</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Cosine distance between 1-D arrays.</span>

<span class="sd">    The Cosine distance between `u` and `v`, is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">        1 - \\frac{u \\cdot v}</span>
<span class="sd">                  {\\|u\\|_2 \\|v\\|_2}.</span>

<span class="sd">    where :math:`u \\cdot v` is the dot product of :math:`u` and</span>
<span class="sd">    :math:`v`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like of floats</span>
<span class="sd">        Input array.</span>

<span class="sd">        .. deprecated:: 1.15.0</span>
<span class="sd">           Complex `u` is deprecated and will raise an error in SciPy 1.17.0</span>
<span class="sd">    v : (N,) array_like of floats</span>
<span class="sd">        Input array.</span>

<span class="sd">        .. deprecated:: 1.15.0</span>
<span class="sd">           Complex `v` is deprecated and will raise an error in SciPy 1.17.0</span>
<span class="sd">    w : (N,) array_like of floats, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cosine : double</span>
<span class="sd">        The Cosine distance between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.cosine([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.cosine([100, 0, 0], [0, 1, 0])</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.cosine([1, 1, 0], [0, 1, 0])</span>
<span class="sd">    0.29289321881345254</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># cosine distance is also referred to as &#39;uncentered correlation&#39;,</span>
    <span class="c1">#   or &#39;reflective correlation&#39;</span>
    <span class="k">return</span> <span class="n">correlation</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">centered</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">hamming</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Hamming distance between two 1-D arrays.</span>

<span class="sd">    The Hamming distance between 1-D arrays `u` and `v`, is simply the</span>
<span class="sd">    proportion of disagreeing components in `u` and `v`. If `u` and `v` are</span>
<span class="sd">    boolean vectors, the Hamming distance is</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\frac{c_{01} + c_{10}}{n}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hamming : double</span>
<span class="sd">        The Hamming distance between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.hamming([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    0.66666666666666663</span>
<span class="sd">    &gt;&gt;&gt; distance.hamming([1, 0, 0], [1, 1, 0])</span>
<span class="sd">    0.33333333333333331</span>
<span class="sd">    &gt;&gt;&gt; distance.hamming([1, 0, 0], [2, 0, 0])</span>
<span class="sd">    0.33333333333333331</span>
<span class="sd">    &gt;&gt;&gt; distance.hamming([1, 0, 0], [3, 0, 0])</span>
<span class="sd">    0.33333333333333331</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The 1d arrays must have equal lengths.&#39;</span><span class="p">)</span>
    <span class="n">u_ne_v</span> <span class="o">=</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">v</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">w</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;w&#39; should have the same length as &#39;u&#39; and &#39;v&#39;.&quot;</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">/</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u_ne_v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">u_ne_v</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">jaccard</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Jaccard dissimilarity between two boolean vectors.</span>

<span class="sd">    Given boolean vectors :math:`u \equiv (u_1, \cdots, u_n)`</span>
<span class="sd">    and :math:`v \equiv (v_1, \cdots, v_n)` that are not both zero,</span>
<span class="sd">    their *Jaccard dissimilarity* is defined as ([1]_, p. 26)</span>

<span class="sd">    .. math::</span>

<span class="sd">       d_\textrm{jaccard}(u, v) := \frac{c_{10} + c_{01}}</span>
<span class="sd">                                        {c_{11} + c_{10} + c_{01}}</span>

<span class="sd">    where</span>

<span class="sd">    .. math::</span>

<span class="sd">       c_{ij} := \sum_{1 \le k \le n, u_k=i, v_k=j} 1</span>

<span class="sd">    for :math:`i, j \in \{ 0, 1\}`.  If :math:`u` and :math:`v` are both zero,</span>
<span class="sd">    their Jaccard dissimilarity is defined to be zero. [2]_</span>

<span class="sd">    If a (non-negative) weight vector :math:`w \equiv (w_1, \cdots, w_n)`</span>
<span class="sd">    is supplied, the *weighted Jaccard dissimilarity* is defined similarly</span>
<span class="sd">    but with :math:`c_{ij}` replaced by</span>

<span class="sd">    .. math::</span>

<span class="sd">       \tilde{c}_{ij} := \sum_{1 \le k \le n, u_k=i, v_k=j} w_k</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like of bools</span>
<span class="sd">        Input vector.</span>
<span class="sd">    v : (N,) array_like of bools</span>
<span class="sd">        Input vector.</span>
<span class="sd">    w : (N,) array_like of floats, optional</span>
<span class="sd">        Weights for each pair of :math:`(u_k, v_k)`.  Default is ``None``,</span>
<span class="sd">        which gives each pair a weight of ``1.0``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jaccard : float</span>
<span class="sd">        The Jaccard dissimilarity between vectors `u` and `v`, optionally</span>
<span class="sd">        weighted by `w` if supplied.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Jaccard dissimilarity satisfies the triangle inequality and is</span>
<span class="sd">    qualified as a metric. [2]_</span>

<span class="sd">    The *Jaccard index*, or *Jaccard similarity coefficient*, is equal to</span>
<span class="sd">    one minus the Jaccard dissimilarity. [3]_</span>

<span class="sd">    The dissimilarity between general (finite) sets may be computed by</span>
<span class="sd">    encoding them as boolean vectors and computing the dissimilarity</span>
<span class="sd">    between the encoded vectors.</span>
<span class="sd">    For example, subsets :math:`A,B` of :math:`\{ 1, 2, ..., n \}` may be</span>
<span class="sd">    encoded into boolean vectors :math:`u, v` by setting</span>
<span class="sd">    :math:`u_k := 1_{k \in A}`, :math:`v_k := 1_{k \in B}`</span>
<span class="sd">    for :math:`k = 1,2,\cdots,n`.</span>

<span class="sd">    .. versionchanged:: 1.2.0</span>
<span class="sd">       Previously, if all (positively weighted) elements in `u` and `v` are</span>
<span class="sd">       zero, the function would return ``nan``.  This was changed to return</span>
<span class="sd">       ``0`` instead.</span>

<span class="sd">    .. versionchanged:: 1.15.0</span>
<span class="sd">       Non-0/1 numeric input used to produce an ad hoc result.  Since 1.15.0,</span>
<span class="sd">       numeric input is converted to Boolean before computation.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Kaufman, L. and Rousseeuw, P. J.  (1990).  &quot;Finding Groups in Data:</span>
<span class="sd">           An Introduction to Cluster Analysis.&quot;  John Wiley &amp; Sons, Inc.</span>
<span class="sd">    .. [2] Kosub, S.  (2019).  &quot;A note on the triangle inequality for the</span>
<span class="sd">           Jaccard distance.&quot;  *Pattern Recognition Letters*, 120:36-38.</span>
<span class="sd">    .. [3] https://en.wikipedia.org/wiki/Jaccard_index</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>

<span class="sd">    Non-zero vectors with no matching 1s have dissimilarity of 1.0:</span>

<span class="sd">    &gt;&gt;&gt; distance.jaccard([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    1.0</span>

<span class="sd">    Vectors with some matching 1s have dissimilarity less than 1.0:</span>

<span class="sd">    &gt;&gt;&gt; distance.jaccard([1, 0, 0, 0], [1, 1, 1, 0])</span>
<span class="sd">    0.6666666666666666</span>

<span class="sd">    Identical vectors, including zero vectors, have dissimilarity of 0.0:</span>

<span class="sd">    &gt;&gt;&gt; distance.jaccard([1, 0, 0], [1, 0, 0])</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; distance.jaccard([0, 0, 0], [0, 0, 0])</span>
<span class="sd">    0.0</span>

<span class="sd">    The following example computes the dissimilarity from a confusion matrix</span>
<span class="sd">    directly by setting the weight vector to the frequency of True Positive,</span>
<span class="sd">    False Negative, False Positive, and True Negative:</span>

<span class="sd">    &gt;&gt;&gt; distance.jaccard([1, 1, 0, 0], [1, 0, 1, 0], [31, 41, 59, 26])</span>
<span class="sd">    0.7633587786259542  # (41+59)/(31+41+59)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="n">unequal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">(</span><span class="n">u</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">nonzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">u</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">unequal</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">unequal</span>
        <span class="n">nonzero</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">nonzero</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">unequal</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">nonzero</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


<span class="n">_deprecated_kulczynski1</span> <span class="o">=</span> <span class="n">_deprecated</span><span class="p">(</span>
    <span class="s2">&quot;The kulczynski1 metric is deprecated since SciPy 1.15.0 and will be &quot;</span>
    <span class="s2">&quot;removed in SciPy 1.17.0.  Replace usage of &#39;kulczynski1(u, v)&#39; with &quot;</span>
    <span class="s2">&quot;&#39;1/jaccard(u, v) - 1&#39;.&quot;</span>
<span class="p">)</span>


<span class="nd">@_deprecated_kulczynski1</span>
<span class="k">def</span><span class="w"> </span><span class="nf">kulczynski1</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Kulczynski 1 dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    .. deprecated:: 1.15.0</span>
<span class="sd">       This function is deprecated and will be removed in SciPy 1.17.0.</span>
<span class="sd">       Replace usage of ``kulczynski1(u, v)`` with ``1/jaccard(u, v) - 1``.</span>

<span class="sd">    The Kulczynski 1 dissimilarity between two boolean 1-D arrays `u` and `v`</span>
<span class="sd">    of length ``n``, is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">         \\frac{c_{11}}</span>
<span class="sd">              {c_{01} + c_{10}}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k \\in {0, 1, ..., n-1}`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    kulczynski1 : float</span>
<span class="sd">        The Kulczynski 1 distance between vectors `u` and `v`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This measure has a minimum value of 0 and no upper limit.</span>
<span class="sd">    It is un-defined when there are no non-matches.</span>

<span class="sd">    .. versionadded:: 1.8.0</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Kulczynski S. et al. Bulletin</span>
<span class="sd">           International de l&#39;Academie Polonaise des Sciences</span>
<span class="sd">           et des Lettres, Classe des Sciences Mathematiques</span>
<span class="sd">           et Naturelles, Serie B (Sciences Naturelles). 1927;</span>
<span class="sd">           Supplement II: 57-203.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.kulczynski1([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; distance.kulczynski1([True, False, False], [True, True, False])</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.kulczynski1([True, False, False], [True])</span>
<span class="sd">    0.5</span>
<span class="sd">    &gt;&gt;&gt; distance.kulczynski1([1, 0, 0], [3, 1, 0])</span>
<span class="sd">    -3.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">,</span> <span class="n">ntt</span><span class="p">)</span> <span class="o">=</span> <span class="n">_nbool_correspond_all</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ntt</span> <span class="o">/</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">seuclidean</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the standardized Euclidean distance between two 1-D arrays.</span>

<span class="sd">    The standardized Euclidean distance between two n-vectors `u` and `v` is</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\sqrt{\\sum\\limits_i \\frac{1}{V_i} \\left(u_i-v_i \\right)^2}</span>

<span class="sd">    ``V`` is the variance vector; ``V[I]`` is the variance computed over all the i-th</span>
<span class="sd">    components of the points. If not passed, it is automatically computed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    V : (N,) array_like</span>
<span class="sd">        `V` is an 1-D array of component variances. It is usually computed</span>
<span class="sd">        among a larger collection of vectors.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    seuclidean : double</span>
<span class="sd">        The standardized Euclidean distance between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.seuclidean([1, 0, 0], [0, 1, 0], [0.1, 0.1, 0.1])</span>
<span class="sd">    4.4721359549995796</span>
<span class="sd">    &gt;&gt;&gt; distance.seuclidean([1, 0, 0], [0, 1, 0], [1, 0.1, 0.1])</span>
<span class="sd">    3.3166247903553998</span>
<span class="sd">    &gt;&gt;&gt; distance.seuclidean([1, 0, 0], [0, 1, 0], [10, 0.1, 0.1])</span>
<span class="sd">    3.1780497164141406</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;V must be a 1-D array of the same dimension &#39;</span>
                        <span class="s1">&#39;as u and v.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">euclidean</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">V</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">cityblock</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the City Block (Manhattan) distance.</span>

<span class="sd">    Computes the Manhattan distance between two 1-D arrays `u` and `v`,</span>
<span class="sd">    which is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\sum_i {\\left| u_i - v_i \\right|}.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cityblock : double</span>
<span class="sd">        The City Block (Manhattan) distance between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.cityblock([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; distance.cityblock([1, 0, 0], [0, 2, 0])</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; distance.cityblock([1, 0, 0], [1, 1, 0])</span>
<span class="sd">    1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">l1_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">l1_diff</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">l1_diff</span>
    <span class="k">return</span> <span class="n">l1_diff</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">mahalanobis</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">VI</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Mahalanobis distance between two 1-D arrays.</span>

<span class="sd">    The Mahalanobis distance between 1-D arrays `u` and `v`, is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\sqrt{ (u-v) V^{-1} (u-v)^T }</span>

<span class="sd">    where ``V`` is the covariance matrix.  Note that the argument `VI`</span>
<span class="sd">    is the inverse of ``V``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    VI : array_like</span>
<span class="sd">        The inverse of the covariance matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mahalanobis : double</span>
<span class="sd">        The Mahalanobis distance between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; iv = [[1, 0.5, 0.5], [0.5, 1, 0.5], [0.5, 0.5, 1]]</span>
<span class="sd">    &gt;&gt;&gt; distance.mahalanobis([1, 0, 0], [0, 1, 0], iv)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.mahalanobis([0, 2, 0], [0, 1, 0], iv)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.mahalanobis([2, 0, 0], [0, 1, 0], iv)</span>
<span class="sd">    1.7320508075688772</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">VI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">VI</span><span class="p">)</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="n">v</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">VI</span><span class="p">),</span> <span class="n">delta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">chebyshev</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Chebyshev distance.</span>

<span class="sd">    The *Chebyshev distance* between real vectors</span>
<span class="sd">    :math:`u \equiv (u_1, \cdots, u_n)` and</span>
<span class="sd">    :math:`v \equiv (v_1, \cdots, v_n)` is defined as [1]_</span>

<span class="sd">    .. math::</span>

<span class="sd">       d_\textrm{chebyshev}(u,v) := \max_{1 \le i \le n} |u_i-v_i|</span>

<span class="sd">    If a (non-negative) weight vector :math:`w \equiv (w_1, \cdots, w_n)`</span>
<span class="sd">    is supplied, the *weighted Chebyshev distance* is defined to be the</span>
<span class="sd">    weighted Minkowski distance of infinite order; that is,</span>

<span class="sd">    .. math::</span>

<span class="sd">       \begin{align}</span>
<span class="sd">       d_\textrm{chebyshev}(u,v;w) &amp;:= \lim_{p\rightarrow \infty}</span>
<span class="sd">          \left( \sum_{i=1}^n w_i | u_i-v_i |^p \right)^\frac{1}{p} \\</span>
<span class="sd">        &amp;= \max_{1 \le i \le n} 1_{w_i &gt; 0} | u_i - v_i |</span>
<span class="sd">       \end{align}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like of floats</span>
<span class="sd">        Input vector.</span>
<span class="sd">    v : (N,) array_like of floats</span>
<span class="sd">        Input vector.</span>
<span class="sd">    w : (N,) array_like of floats, optional</span>
<span class="sd">        Weight vector.  Default is ``None``, which gives all pairs</span>
<span class="sd">        :math:`(u_i, v_i)` the same weight ``1.0``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    chebyshev : float</span>
<span class="sd">        The Chebyshev distance between vectors `u` and `v`, optionally weighted</span>
<span class="sd">        by `w`.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://en.wikipedia.org/wiki/Chebyshev_distance</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.chebyshev([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; distance.chebyshev([1, 1, 0], [0, 1, 0])</span>
<span class="sd">    1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">((</span><span class="n">w</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">v</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">v</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">braycurtis</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Bray-Curtis distance between two 1-D arrays.</span>

<span class="sd">    Bray-Curtis distance is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\sum{|u_i-v_i|} / \\sum{|u_i+v_i|}</span>

<span class="sd">    The Bray-Curtis distance is in the range [0, 1] if all coordinates are</span>
<span class="sd">    positive, and is undefined if the inputs are of length zero.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    braycurtis : double</span>
<span class="sd">        The Bray-Curtis distance between 1-D arrays `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.braycurtis([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.braycurtis([1, 1, 0], [0, 1, 0])</span>
<span class="sd">    0.33333333333333331</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">l1_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">l1_sum</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">l1_diff</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">l1_diff</span>
        <span class="n">l1_sum</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">l1_sum</span>
    <span class="k">return</span> <span class="n">l1_diff</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">l1_sum</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">canberra</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Canberra distance between two 1-D arrays.</span>

<span class="sd">    The Canberra distance is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">         d(u,v) = \\sum_i \\frac{|u_i-v_i|}</span>
<span class="sd">                              {|u_i|+|v_i|}.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    canberra : double</span>
<span class="sd">        The Canberra distance between vectors `u` and `v`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When ``u[i]`` and ``v[i]`` are 0 for given i, then the fraction 0/0 = 0 is</span>
<span class="sd">    used in the calculation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.canberra([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; distance.canberra([1, 1, 0], [0, 1, 0])</span>
<span class="sd">    1.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
        <span class="n">abs_uv</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">abs_u</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">abs_v</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">abs_uv</span> <span class="o">/</span> <span class="p">(</span><span class="n">abs_u</span> <span class="o">+</span> <span class="n">abs_v</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">d</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span>


<span class="k">def</span><span class="w"> </span><span class="nf">jensenshannon</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Jensen-Shannon distance (metric) between</span>
<span class="sd">    two probability arrays. This is the square root</span>
<span class="sd">    of the Jensen-Shannon divergence.</span>

<span class="sd">    The Jensen-Shannon distance between two probability</span>
<span class="sd">    vectors `p` and `q` is defined as,</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\sqrt{\\frac{D(p \\parallel m) + D(q \\parallel m)}{2}}</span>

<span class="sd">    where :math:`m` is the pointwise mean of :math:`p` and :math:`q`</span>
<span class="sd">    and :math:`D` is the Kullback-Leibler divergence.</span>

<span class="sd">    This routine will normalize `p` and `q` if they don&#39;t sum to 1.0.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p : (N,) array_like</span>
<span class="sd">        left probability vector</span>
<span class="sd">    q : (N,) array_like</span>
<span class="sd">        right probability vector</span>
<span class="sd">    base : double, optional</span>
<span class="sd">        the base of the logarithm used to compute the output</span>
<span class="sd">        if not given, then the routine uses the default base of</span>
<span class="sd">        scipy.stats.entropy.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which the Jensen-Shannon distances are computed. The default</span>
<span class="sd">        is 0.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to `True`, the reduced axes are left in the</span>
<span class="sd">        result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the input array.</span>
<span class="sd">        Default is False.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    js : double or ndarray</span>
<span class="sd">        The Jensen-Shannon distances between `p` and `q` along the `axis`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    .. versionadded:: 1.2.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; distance.jensenshannon([1.0, 0.0, 0.0], [0.0, 1.0, 0.0], 2.0)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.jensenshannon([1.0, 0.0], [0.5, 0.5])</span>
<span class="sd">    0.46450140402245893</span>
<span class="sd">    &gt;&gt;&gt; distance.jensenshannon([1.0, 0.0, 0.0], [1.0, 0.0, 0.0])</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2, 3, 4],</span>
<span class="sd">    ...               [5, 6, 7, 8],</span>
<span class="sd">    ...               [9, 10, 11, 12]])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([[13, 14, 15, 16],</span>
<span class="sd">    ...               [17, 18, 19, 20],</span>
<span class="sd">    ...               [21, 22, 23, 24]])</span>
<span class="sd">    &gt;&gt;&gt; distance.jensenshannon(a, b, axis=0)</span>
<span class="sd">    array([0.1954288, 0.1447697, 0.1138377, 0.0927636])</span>
<span class="sd">    &gt;&gt;&gt; distance.jensenshannon(a, b, axis=1)</span>
<span class="sd">    array([0.1402339, 0.0399106, 0.0201815])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">q</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">rel_entr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">rel_entr</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">left_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
    <span class="n">right_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
    <span class="n">js</span> <span class="o">=</span> <span class="n">left_sum</span> <span class="o">+</span> <span class="n">right_sum</span>
    <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">js</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">js</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">yule</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Yule dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    The Yule dissimilarity is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">         \\frac{R}{c_{TT} * c_{FF} + \\frac{R}{2}}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n` and :math:`R = 2.0 * c_{TF} * c_{FT}`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    yule : double</span>
<span class="sd">        The Yule dissimilarity between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.yule([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; distance.yule([1, 1, 0], [0, 1, 0])</span>
<span class="sd">    0.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="p">(</span><span class="n">nff</span><span class="p">,</span> <span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">,</span> <span class="n">ntt</span><span class="p">)</span> <span class="o">=</span> <span class="n">_nbool_correspond_all</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
    <span class="n">half_R</span> <span class="o">=</span> <span class="n">ntf</span> <span class="o">*</span> <span class="n">nft</span>
    <span class="k">if</span> <span class="n">half_R</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">half_R</span> <span class="o">/</span> <span class="p">(</span><span class="n">ntt</span> <span class="o">*</span> <span class="n">nff</span> <span class="o">+</span> <span class="n">half_R</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">dice</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Dice dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    The Dice dissimilarity between `u` and `v`, is</span>

<span class="sd">    .. math::</span>

<span class="sd">         \\frac{c_{TF} + c_{FT}}</span>
<span class="sd">              {2c_{TT} + c_{FT} + c_{TF}}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like, bool</span>
<span class="sd">        Input 1-D array.</span>
<span class="sd">    v : (N,) array_like, bool</span>
<span class="sd">        Input 1-D array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dice : double</span>
<span class="sd">        The Dice dissimilarity between 1-D arrays `u` and `v`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function computes the Dice dissimilarity index. To compute the</span>
<span class="sd">    Dice similarity index, convert one to the other with similarity =</span>
<span class="sd">    1 - dissimilarity.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.dice([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.dice([1, 0, 0], [1, 1, 0])</span>
<span class="sd">    0.3333333333333333</span>
<span class="sd">    &gt;&gt;&gt; distance.dice([1, 0, 0], [2, 0, 0])</span>
<span class="sd">    -0.3333333333333333</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span> <span class="ow">and</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="p">(</span><span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">)</span> <span class="o">=</span> <span class="n">_nbool_correspond_ft_tf</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">((</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">ntt</span> <span class="o">+</span> <span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">rogerstanimoto</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Rogers-Tanimoto dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    The Rogers-Tanimoto dissimilarity between two boolean 1-D arrays</span>
<span class="sd">    `u` and `v`, is defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">       \\frac{R}</span>
<span class="sd">            {c_{TT} + c_{FF} + R}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n` and :math:`R = 2(c_{TF} + c_{FT})`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rogerstanimoto : double</span>
<span class="sd">        The Rogers-Tanimoto dissimilarity between vectors</span>
<span class="sd">        `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.rogerstanimoto([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    0.8</span>
<span class="sd">    &gt;&gt;&gt; distance.rogerstanimoto([1, 0, 0], [1, 1, 0])</span>
<span class="sd">    0.5</span>
<span class="sd">    &gt;&gt;&gt; distance.rogerstanimoto([1, 0, 0], [2, 0, 0])</span>
<span class="sd">    -1.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="p">(</span><span class="n">nff</span><span class="p">,</span> <span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">,</span> <span class="n">ntt</span><span class="p">)</span> <span class="o">=</span> <span class="n">_nbool_correspond_all</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">))</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">ntt</span> <span class="o">+</span> <span class="n">nff</span> <span class="o">+</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">)))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">russellrao</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Russell-Rao dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    The Russell-Rao dissimilarity between two boolean 1-D arrays, `u` and</span>
<span class="sd">    `v`, is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">      \\frac{n - c_{TT}}</span>
<span class="sd">           {n}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    russellrao : double</span>
<span class="sd">        The Russell-Rao dissimilarity between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.russellrao([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.russellrao([1, 0, 0], [1, 1, 0])</span>
<span class="sd">    0.6666666666666666</span>
<span class="sd">    &gt;&gt;&gt; distance.russellrao([1, 0, 0], [2, 0, 0])</span>
<span class="sd">    0.3333333333333333</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span> <span class="ow">and</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">ntt</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>


<span class="n">_deprecated_sokalmichener</span> <span class="o">=</span> <span class="n">_deprecated</span><span class="p">(</span>
    <span class="s2">&quot;The sokalmichener metric is deprecated since SciPy 1.15.0 and will be &quot;</span>
    <span class="s2">&quot;removed in SciPy 1.17.0.  Replace usage of &#39;sokalmichener(u, v)&#39; with &quot;</span>
    <span class="s2">&quot;&#39;rogerstanimoto(u, v)&#39;.&quot;</span>
<span class="p">)</span>


<span class="nd">@_deprecated_sokalmichener</span>
<span class="k">def</span><span class="w"> </span><span class="nf">sokalmichener</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Sokal-Michener dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    .. deprecated:: 1.15.0</span>
<span class="sd">       This function is deprecated and will be removed in SciPy 1.17.0.</span>
<span class="sd">       Replace usage of ``sokalmichener(u, v)`` with ``rogerstanimoto(u, v)``.</span>

<span class="sd">    The Sokal-Michener dissimilarity between boolean 1-D arrays `u` and `v`,</span>
<span class="sd">    is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\frac{R}</span>
<span class="sd">            {S + R}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n`, :math:`R = 2 * (c_{TF} + c_{FT})` and</span>
<span class="sd">    :math:`S = c_{FF} + c_{TT}`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sokalmichener : double</span>
<span class="sd">        The Sokal-Michener dissimilarity between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.sokalmichener([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    0.8</span>
<span class="sd">    &gt;&gt;&gt; distance.sokalmichener([1, 0, 0], [1, 1, 0])</span>
<span class="sd">    0.5</span>
<span class="sd">    &gt;&gt;&gt; distance.sokalmichener([1, 0, 0], [2, 0, 0])</span>
<span class="sd">    -1.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="n">nff</span><span class="p">,</span> <span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">,</span> <span class="n">ntt</span> <span class="o">=</span> <span class="n">_nbool_correspond_all</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">))</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">ntt</span> <span class="o">+</span> <span class="n">nff</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">sokalsneath</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Sokal-Sneath dissimilarity between two boolean 1-D arrays.</span>

<span class="sd">    The Sokal-Sneath dissimilarity between `u` and `v`,</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\frac{R}</span>
<span class="sd">            {c_{TT} + R}</span>

<span class="sd">    where :math:`c_{ij}` is the number of occurrences of</span>
<span class="sd">    :math:`\\mathtt{u[k]} = i` and :math:`\\mathtt{v[k]} = j` for</span>
<span class="sd">    :math:`k &lt; n` and :math:`R = 2(c_{TF} + c_{FT})`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    v : (N,) array_like, bool</span>
<span class="sd">        Input array.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        The weights for each value in `u` and `v`. Default is None,</span>
<span class="sd">        which gives each value a weight of 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sokalsneath : double</span>
<span class="sd">        The Sokal-Sneath dissimilarity between vectors `u` and `v`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; distance.sokalsneath([1, 0, 0], [0, 1, 0])</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; distance.sokalsneath([1, 0, 0], [1, 1, 0])</span>
<span class="sd">    0.66666666666666663</span>
<span class="sd">    &gt;&gt;&gt; distance.sokalsneath([1, 0, 0], [2, 1, 0])</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; distance.sokalsneath([1, 0, 0], [3, 1, 0])</span>
<span class="sd">    -2.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">_validate_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span> <span class="ow">and</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_validate_weights</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">ntt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">v</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="p">(</span><span class="n">nft</span><span class="p">,</span> <span class="n">ntf</span><span class="p">)</span> <span class="o">=</span> <span class="n">_nbool_correspond_ft_tf</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ntt</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">denom</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Sokal-Sneath dissimilarity is not defined for &#39;</span>
                         <span class="s1">&#39;vectors that are entirely false.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ntf</span> <span class="o">+</span> <span class="n">nft</span><span class="p">))</span> <span class="o">/</span> <span class="n">denom</span>


<span class="n">_convert_to_double</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_convert_to_type</span><span class="p">,</span> <span class="n">out_type</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">_convert_to_bool</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_convert_to_type</span><span class="p">,</span> <span class="n">out_type</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

<span class="c1"># adding python-only wrappers to _distance_wrap module</span>
<span class="n">_distance_wrap</span><span class="o">.</span><span class="n">pdist_correlation_double_wrap</span> <span class="o">=</span> <span class="n">_correlation_pdist_wrap</span>
<span class="n">_distance_wrap</span><span class="o">.</span><span class="n">cdist_correlation_double_wrap</span> <span class="o">=</span> <span class="n">_correlation_cdist_wrap</span>


<span class="nd">@dataclasses</span><span class="o">.</span><span class="n">dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CDistMetricWrapper</span><span class="p">:</span>
    <span class="n">metric_name</span><span class="p">:</span> <span class="nb">str</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">XA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">XA</span><span class="p">)</span>
        <span class="n">XB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">XB</span><span class="p">)</span>
        <span class="n">mA</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">XA</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">mB</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">XB</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">metric_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric_name</span>
        <span class="n">metric_info</span> <span class="o">=</span> <span class="n">_METRICS</span><span class="p">[</span><span class="n">metric_name</span><span class="p">]</span>
        <span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_validate_cdist_input</span><span class="p">(</span>
            <span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">mA</span><span class="p">,</span> <span class="n">mB</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">metric_info</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">w</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="n">metric_info</span><span class="o">.</span><span class="n">dist_func</span>
            <span class="k">return</span> <span class="n">_cdist_callable</span><span class="p">(</span>
                <span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="n">_prepare_out_argument</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="n">mA</span><span class="p">,</span> <span class="n">mB</span><span class="p">))</span>
        <span class="c1"># get cdist wrapper</span>
        <span class="n">cdist_fn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_distance_wrap</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cdist_</span><span class="si">{</span><span class="n">metric_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">typ</span><span class="si">}</span><span class="s1">_wrap&#39;</span><span class="p">)</span>
        <span class="n">cdist_fn</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dm</span>


<span class="nd">@dataclasses</span><span class="o">.</span><span class="n">dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PDistMetricWrapper</span><span class="p">:</span>
    <span class="n">metric_name</span><span class="p">:</span> <span class="nb">str</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">metric_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric_name</span>
        <span class="n">metric_info</span> <span class="o">=</span> <span class="n">_METRICS</span><span class="p">[</span><span class="n">metric_name</span><span class="p">]</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_validate_pdist_input</span><span class="p">(</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">metric_info</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">out_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="n">metric_info</span><span class="o">.</span><span class="n">dist_func</span>
            <span class="k">return</span> <span class="n">_pdist_callable</span><span class="p">(</span>
                <span class="n">X</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="n">_prepare_out_argument</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="n">out_size</span><span class="p">,))</span>
        <span class="c1"># get pdist wrapper</span>
        <span class="n">pdist_fn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_distance_wrap</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;pdist_</span><span class="si">{</span><span class="n">metric_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">typ</span><span class="si">}</span><span class="s1">_wrap&#39;</span><span class="p">)</span>
        <span class="n">pdist_fn</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dm</span>


<span class="nd">@dataclasses</span><span class="o">.</span><span class="n">dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MetricInfo</span><span class="p">:</span>
    <span class="c1"># Name of python distance function</span>
    <span class="n">canonical_name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="c1"># All aliases, including canonical_name</span>
    <span class="n">aka</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="c1"># unvectorized distance function</span>
    <span class="n">dist_func</span><span class="p">:</span> <span class="n">Callable</span>
    <span class="c1"># Optimized cdist function</span>
    <span class="n">cdist_func</span><span class="p">:</span> <span class="n">Callable</span>
    <span class="c1"># Optimized pdist function</span>
    <span class="n">pdist_func</span><span class="p">:</span> <span class="n">Callable</span>
    <span class="c1"># function that checks kwargs and computes default values:</span>
    <span class="c1"># f(X, m, n, **kwargs)</span>
    <span class="n">validator</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># list of supported types:</span>
    <span class="c1"># X (pdist) and XA (cdist) are used to choose the type. if there is no</span>
    <span class="c1"># match the first type is used. Default double</span>
    <span class="n">types</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;double&#39;</span><span class="p">])</span>
    <span class="c1"># true if out array must be C-contiguous</span>
    <span class="n">requires_contiguous_out</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>


<span class="c1"># Registry of implemented metrics:</span>
<span class="n">_METRIC_INFOS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">MetricInfo</span><span class="p">(</span>
        <span class="n">canonical_name</span><span class="o">=</span><span class="s1">&#39;braycurtis&#39;</span><span class="p">,</span>
        <span class="n">aka</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;braycurtis&#39;</span><span class="p">},</span>
        <span class="n">dist_func</span><span class="o">=</span><span class="n">braycurtis</span><span class="p">,</span>
        <span class="n">cdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">cdist_braycurtis</span><span class="p">,</span>
        <span class="n">pdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">pdist_braycurtis</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">MetricInfo</span><span class="p">(</span>
        <span class="n">canonical_name</span><span class="o">=</span><span class="s1">&#39;canberra&#39;</span><span class="p">,</span>
        <span class="n">aka</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;canberra&#39;</span><span class="p">},</span>
        <span class="n">dist_func</span><span class="o">=</span><span class="n">canberra</span><span class="p">,</span>
        <span class="n">cdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">cdist_canberra</span><span class="p">,</span>
        <span class="n">pdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">pdist_canberra</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">MetricInfo</span><span class="p">(</span>
        <span class="n">canonical_name</span><span class="o">=</span><span class="s1">&#39;chebyshev&#39;</span><span class="p">,</span>
        <span class="n">aka</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;chebychev&#39;</span><span class="p">,</span> <span class="s1">&#39;chebyshev&#39;</span><span class="p">,</span> <span class="s1">&#39;cheby&#39;</span><span class="p">,</span> <span class="s1">&#39;cheb&#39;</span><span class="p">,</span> <span class="s1">&#39;ch&#39;</span><span class="p">},</span>
        <span class="n">dist_func</span><span class="o">=</span><span class="n">chebyshev</span><span class="p">,</span>
        <span class="n">cdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">cdist_chebyshev</span><span class="p">,</span>
        <span class="n">pdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">pdist_chebyshev</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">MetricInfo</span><span class="p">(</span>
        <span class="n">canonical_name</span><span class="o">=</span><span class="s1">&#39;cityblock&#39;</span><span class="p">,</span>
        <span class="n">aka</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;cityblock&#39;</span><span class="p">,</span> <span class="s1">&#39;cblock&#39;</span><span class="p">,</span> <span class="s1">&#39;cb&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">},</span>
        <span class="n">dist_func</span><span class="o">=</span><span class="n">cityblock</span><span class="p">,</span>
        <span class="n">cdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">cdist_cityblock</span><span class="p">,</span>
        <span class="n">pdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">pdist_cityblock</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">MetricInfo</span><span class="p">(</span>
        <span class="n">canonical_name</span><span class="o">=</span><span class="s1">&#39;correlation&#39;</span><span class="p">,</span>
        <span class="n">aka</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;correlation&#39;</span><span class="p">,</span> <span class="s1">&#39;co&#39;</span><span class="p">},</span>
        <span class="n">dist_func</span><span class="o">=</span><span class="n">correlation</span><span class="p">,</span>
        <span class="n">cdist_func</span><span class="o">=</span><span class="n">CDistMetricWrapper</span><span class="p">(</span><span class="s1">&#39;correlation&#39;</span><span class="p">),</span>
        <span class="n">pdist_func</span><span class="o">=</span><span class="n">PDistMetricWrapper</span><span class="p">(</span><span class="s1">&#39;correlation&#39;</span><span class="p">),</span>
    <span class="p">),</span>
    <span class="n">MetricInfo</span><span class="p">(</span>
        <span class="n">canonical_name</span><span class="o">=</span><span class="s1">&#39;cosine&#39;</span><span class="p">,</span>
        <span class="n">aka</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;cosine&#39;</span><span class="p">,</span> <span class="s1">&#39;cos&#39;</span><span class="p">},</span>
        <span class="n">dist_func</span><span class="o">=</span><span class="n">cosine</span><span class="p">,</span>
        <span class="n">cdist_func</span><span class="o">=</span><span class="n">CDistMetricWrapper</span><span class="p">(</span><span class="s1">&#39;cosine&#39;</span><span class="p">),</span>
        <span class="n">pdist_func</span><span class="o">=</span><span class="n">PDistMetricWrapper</span><span class="p">(</span><span class="s1">&#39;cosine&#39;</span><span class="p">),</span>
    <span class="p">),</span>
    <span class="n">MetricInfo</span><span class="p">(</span>
        <span class="n">canonical_name</span><span class="o">=</span><span class="s1">&#39;dice&#39;</span><span class="p">,</span>
        <span class="n">aka</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dice&#39;</span><span class="p">},</span>
        <span class="n">types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;bool&#39;</span><span class="p">],</span>
        <span class="n">dist_func</span><span class="o">=</span><span class="n">dice</span><span class="p">,</span>
        <span class="n">cdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">cdist_dice</span><span class="p">,</span>
        <span class="n">pdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">pdist_dice</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">MetricInfo</span><span class="p">(</span>
        <span class="n">canonical_name</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span>
        <span class="n">aka</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;euclid&#39;</span><span class="p">,</span> <span class="s1">&#39;eu&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">},</span>
        <span class="n">dist_func</span><span class="o">=</span><span class="n">euclidean</span><span class="p">,</span>
        <span class="n">cdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">cdist_euclidean</span><span class="p">,</span>
        <span class="n">pdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">pdist_euclidean</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">MetricInfo</span><span class="p">(</span>
        <span class="n">canonical_name</span><span class="o">=</span><span class="s1">&#39;hamming&#39;</span><span class="p">,</span>
        <span class="n">aka</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;matching&#39;</span><span class="p">,</span> <span class="s1">&#39;hamming&#39;</span><span class="p">,</span> <span class="s1">&#39;hamm&#39;</span><span class="p">,</span> <span class="s1">&#39;ha&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">},</span>
        <span class="n">types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;double&#39;</span><span class="p">,</span> <span class="s1">&#39;bool&#39;</span><span class="p">],</span>
        <span class="n">validator</span><span class="o">=</span><span class="n">_validate_hamming_kwargs</span><span class="p">,</span>
        <span class="n">dist_func</span><span class="o">=</span><span class="n">hamming</span><span class="p">,</span>
        <span class="n">cdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">cdist_hamming</span><span class="p">,</span>
        <span class="n">pdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">pdist_hamming</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">MetricInfo</span><span class="p">(</span>
        <span class="n">canonical_name</span><span class="o">=</span><span class="s1">&#39;jaccard&#39;</span><span class="p">,</span>
        <span class="n">aka</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;jaccard&#39;</span><span class="p">,</span> <span class="s1">&#39;jacc&#39;</span><span class="p">,</span> <span class="s1">&#39;ja&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">},</span>
        <span class="n">types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;double&#39;</span><span class="p">,</span> <span class="s1">&#39;bool&#39;</span><span class="p">],</span>
        <span class="n">dist_func</span><span class="o">=</span><span class="n">jaccard</span><span class="p">,</span>
        <span class="n">cdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">cdist_jaccard</span><span class="p">,</span>
        <span class="n">pdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">pdist_jaccard</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">MetricInfo</span><span class="p">(</span>
        <span class="n">canonical_name</span><span class="o">=</span><span class="s1">&#39;jensenshannon&#39;</span><span class="p">,</span>
        <span class="n">aka</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;jensenshannon&#39;</span><span class="p">,</span> <span class="s1">&#39;js&#39;</span><span class="p">},</span>
        <span class="n">dist_func</span><span class="o">=</span><span class="n">jensenshannon</span><span class="p">,</span>
        <span class="n">cdist_func</span><span class="o">=</span><span class="n">CDistMetricWrapper</span><span class="p">(</span><span class="s1">&#39;jensenshannon&#39;</span><span class="p">),</span>
        <span class="n">pdist_func</span><span class="o">=</span><span class="n">PDistMetricWrapper</span><span class="p">(</span><span class="s1">&#39;jensenshannon&#39;</span><span class="p">),</span>
    <span class="p">),</span>
    <span class="n">MetricInfo</span><span class="p">(</span>
        <span class="n">canonical_name</span><span class="o">=</span><span class="s1">&#39;kulczynski1&#39;</span><span class="p">,</span>
        <span class="n">aka</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;kulczynski1&#39;</span><span class="p">},</span>
        <span class="n">types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;bool&#39;</span><span class="p">],</span>
        <span class="n">dist_func</span><span class="o">=</span><span class="n">kulczynski1</span><span class="p">,</span>
        <span class="n">cdist_func</span><span class="o">=</span><span class="n">_deprecated_kulczynski1</span><span class="p">(</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">cdist_kulczynski1</span><span class="p">),</span>
        <span class="n">pdist_func</span><span class="o">=</span><span class="n">_deprecated_kulczynski1</span><span class="p">(</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">pdist_kulczynski1</span><span class="p">),</span>
    <span class="p">),</span>
    <span class="n">MetricInfo</span><span class="p">(</span>
        <span class="n">canonical_name</span><span class="o">=</span><span class="s1">&#39;mahalanobis&#39;</span><span class="p">,</span>
        <span class="n">aka</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;mahalanobis&#39;</span><span class="p">,</span> <span class="s1">&#39;mahal&#39;</span><span class="p">,</span> <span class="s1">&#39;mah&#39;</span><span class="p">},</span>
        <span class="n">validator</span><span class="o">=</span><span class="n">_validate_mahalanobis_kwargs</span><span class="p">,</span>
        <span class="n">dist_func</span><span class="o">=</span><span class="n">mahalanobis</span><span class="p">,</span>
        <span class="n">cdist_func</span><span class="o">=</span><span class="n">CDistMetricWrapper</span><span class="p">(</span><span class="s1">&#39;mahalanobis&#39;</span><span class="p">),</span>
        <span class="n">pdist_func</span><span class="o">=</span><span class="n">PDistMetricWrapper</span><span class="p">(</span><span class="s1">&#39;mahalanobis&#39;</span><span class="p">),</span>
    <span class="p">),</span>
    <span class="n">MetricInfo</span><span class="p">(</span>
        <span class="n">canonical_name</span><span class="o">=</span><span class="s1">&#39;minkowski&#39;</span><span class="p">,</span>
        <span class="n">aka</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;minkowski&#39;</span><span class="p">,</span> <span class="s1">&#39;mi&#39;</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;pnorm&#39;</span><span class="p">},</span>
        <span class="n">validator</span><span class="o">=</span><span class="n">_validate_minkowski_kwargs</span><span class="p">,</span>
        <span class="n">dist_func</span><span class="o">=</span><span class="n">minkowski</span><span class="p">,</span>
        <span class="n">cdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">cdist_minkowski</span><span class="p">,</span>
        <span class="n">pdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">pdist_minkowski</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">MetricInfo</span><span class="p">(</span>
        <span class="n">canonical_name</span><span class="o">=</span><span class="s1">&#39;rogerstanimoto&#39;</span><span class="p">,</span>
        <span class="n">aka</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;rogerstanimoto&#39;</span><span class="p">},</span>
        <span class="n">types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;bool&#39;</span><span class="p">],</span>
        <span class="n">dist_func</span><span class="o">=</span><span class="n">rogerstanimoto</span><span class="p">,</span>
        <span class="n">cdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">cdist_rogerstanimoto</span><span class="p">,</span>
        <span class="n">pdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">pdist_rogerstanimoto</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">MetricInfo</span><span class="p">(</span>
        <span class="n">canonical_name</span><span class="o">=</span><span class="s1">&#39;russellrao&#39;</span><span class="p">,</span>
        <span class="n">aka</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;russellrao&#39;</span><span class="p">},</span>
        <span class="n">types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;bool&#39;</span><span class="p">],</span>
        <span class="n">dist_func</span><span class="o">=</span><span class="n">russellrao</span><span class="p">,</span>
        <span class="n">cdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">cdist_russellrao</span><span class="p">,</span>
        <span class="n">pdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">pdist_russellrao</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">MetricInfo</span><span class="p">(</span>
        <span class="n">canonical_name</span><span class="o">=</span><span class="s1">&#39;seuclidean&#39;</span><span class="p">,</span>
        <span class="n">aka</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;seuclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;se&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">},</span>
        <span class="n">validator</span><span class="o">=</span><span class="n">_validate_seuclidean_kwargs</span><span class="p">,</span>
        <span class="n">dist_func</span><span class="o">=</span><span class="n">seuclidean</span><span class="p">,</span>
        <span class="n">cdist_func</span><span class="o">=</span><span class="n">CDistMetricWrapper</span><span class="p">(</span><span class="s1">&#39;seuclidean&#39;</span><span class="p">),</span>
        <span class="n">pdist_func</span><span class="o">=</span><span class="n">PDistMetricWrapper</span><span class="p">(</span><span class="s1">&#39;seuclidean&#39;</span><span class="p">),</span>
    <span class="p">),</span>
    <span class="n">MetricInfo</span><span class="p">(</span>
        <span class="n">canonical_name</span><span class="o">=</span><span class="s1">&#39;sokalmichener&#39;</span><span class="p">,</span>
        <span class="n">aka</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;sokalmichener&#39;</span><span class="p">},</span>
        <span class="n">types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;bool&#39;</span><span class="p">],</span>
        <span class="n">dist_func</span><span class="o">=</span><span class="n">sokalmichener</span><span class="p">,</span>
        <span class="n">cdist_func</span><span class="o">=</span><span class="n">_deprecated_sokalmichener</span><span class="p">(</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">cdist_sokalmichener</span><span class="p">),</span>
        <span class="n">pdist_func</span><span class="o">=</span><span class="n">_deprecated_sokalmichener</span><span class="p">(</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">pdist_sokalmichener</span><span class="p">),</span>
    <span class="p">),</span>
    <span class="n">MetricInfo</span><span class="p">(</span>
        <span class="n">canonical_name</span><span class="o">=</span><span class="s1">&#39;sokalsneath&#39;</span><span class="p">,</span>
        <span class="n">aka</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;sokalsneath&#39;</span><span class="p">},</span>
        <span class="n">types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;bool&#39;</span><span class="p">],</span>
        <span class="n">dist_func</span><span class="o">=</span><span class="n">sokalsneath</span><span class="p">,</span>
        <span class="n">cdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">cdist_sokalsneath</span><span class="p">,</span>
        <span class="n">pdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">pdist_sokalsneath</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">MetricInfo</span><span class="p">(</span>
        <span class="n">canonical_name</span><span class="o">=</span><span class="s1">&#39;sqeuclidean&#39;</span><span class="p">,</span>
        <span class="n">aka</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;sqeuclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;sqe&#39;</span><span class="p">,</span> <span class="s1">&#39;sqeuclid&#39;</span><span class="p">},</span>
        <span class="n">dist_func</span><span class="o">=</span><span class="n">sqeuclidean</span><span class="p">,</span>
        <span class="n">cdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">cdist_sqeuclidean</span><span class="p">,</span>
        <span class="n">pdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">pdist_sqeuclidean</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">MetricInfo</span><span class="p">(</span>
        <span class="n">canonical_name</span><span class="o">=</span><span class="s1">&#39;yule&#39;</span><span class="p">,</span>
        <span class="n">aka</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;yule&#39;</span><span class="p">},</span>
        <span class="n">types</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;bool&#39;</span><span class="p">],</span>
        <span class="n">dist_func</span><span class="o">=</span><span class="n">yule</span><span class="p">,</span>
        <span class="n">cdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">cdist_yule</span><span class="p">,</span>
        <span class="n">pdist_func</span><span class="o">=</span><span class="n">_distance_pybind</span><span class="o">.</span><span class="n">pdist_yule</span><span class="p">,</span>
    <span class="p">),</span>
<span class="p">]</span>

<span class="n">_METRICS</span> <span class="o">=</span> <span class="p">{</span><span class="n">info</span><span class="o">.</span><span class="n">canonical_name</span><span class="p">:</span> <span class="n">info</span> <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">_METRIC_INFOS</span><span class="p">}</span>
<span class="n">_METRIC_ALIAS</span> <span class="o">=</span> <span class="p">{</span><span class="n">alias</span><span class="p">:</span> <span class="n">info</span>
                     <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">_METRIC_INFOS</span>
                     <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">info</span><span class="o">.</span><span class="n">aka</span><span class="p">}</span>

<span class="n">_METRICS_NAMES</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_METRICS</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

<span class="n">_TEST_METRICS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;test_&#39;</span> <span class="o">+</span> <span class="n">info</span><span class="o">.</span><span class="n">canonical_name</span><span class="p">:</span> <span class="n">info</span> <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">_METRIC_INFOS</span><span class="p">}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">pdist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pairwise distances between observations in n-dimensional space.</span>

<span class="sd">    See Notes for common calling conventions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : array_like</span>
<span class="sd">        An m by n array of m original observations in an</span>
<span class="sd">        n-dimensional space.</span>
<span class="sd">    metric : str or function, optional</span>
<span class="sd">        The distance metric to use. The distance function can</span>
<span class="sd">        be &#39;braycurtis&#39;, &#39;canberra&#39;, &#39;chebyshev&#39;, &#39;cityblock&#39;,</span>
<span class="sd">        &#39;correlation&#39;, &#39;cosine&#39;, &#39;dice&#39;, &#39;euclidean&#39;, &#39;hamming&#39;,</span>
<span class="sd">        &#39;jaccard&#39;, &#39;jensenshannon&#39;, &#39;kulczynski1&#39;,</span>
<span class="sd">        &#39;mahalanobis&#39;, &#39;matching&#39;, &#39;minkowski&#39;, &#39;rogerstanimoto&#39;,</span>
<span class="sd">        &#39;russellrao&#39;, &#39;seuclidean&#39;, &#39;sokalmichener&#39;, &#39;sokalsneath&#39;,</span>
<span class="sd">        &#39;sqeuclidean&#39;, &#39;yule&#39;.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        The output array.</span>
<span class="sd">        If not None, condensed distance matrix Y is stored in this array.</span>
<span class="sd">    **kwargs : dict, optional</span>
<span class="sd">        Extra arguments to `metric`: refer to each metric documentation for a</span>
<span class="sd">        list of all possible arguments.</span>

<span class="sd">        Some possible arguments:</span>

<span class="sd">        p : scalar</span>
<span class="sd">        The p-norm to apply for Minkowski, weighted and unweighted.</span>
<span class="sd">        Default: 2.</span>

<span class="sd">        w : ndarray</span>
<span class="sd">        The weight vector for metrics that support weights (e.g., Minkowski).</span>

<span class="sd">        V : ndarray</span>
<span class="sd">        The variance vector for standardized Euclidean.</span>
<span class="sd">        Default: var(X, axis=0, ddof=1)</span>

<span class="sd">        VI : ndarray</span>
<span class="sd">        The inverse of the covariance matrix for Mahalanobis.</span>
<span class="sd">        Default: inv(cov(X.T)).T</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Y : ndarray</span>
<span class="sd">        Returns a condensed distance matrix Y. For each :math:`i` and :math:`j`</span>
<span class="sd">        (where :math:`i&lt;j&lt;m`),where m is the number of original observations.</span>
<span class="sd">        The metric ``dist(u=X[i], v=X[j])`` is computed and stored in entry ``m</span>
<span class="sd">        * i + j - ((i + 2) * (i + 1)) // 2``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    squareform : converts between condensed distance matrices and</span>
<span class="sd">                 square distance matrices.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See ``squareform`` for information on how to calculate the index of</span>
<span class="sd">    this entry or to convert the condensed distance matrix to a</span>
<span class="sd">    redundant square matrix.</span>

<span class="sd">    The following are common calling conventions.</span>

<span class="sd">    1. ``Y = pdist(X, &#39;euclidean&#39;)``</span>

<span class="sd">       Computes the distance between m points using Euclidean distance</span>
<span class="sd">       (2-norm) as the distance metric between the points. The points</span>
<span class="sd">       are arranged as m n-dimensional row vectors in the matrix X.</span>

<span class="sd">    2. ``Y = pdist(X, &#39;minkowski&#39;, p=2.)``</span>

<span class="sd">       Computes the distances using the Minkowski distance</span>
<span class="sd">       :math:`\\|u-v\\|_p` (:math:`p`-norm) where :math:`p &gt; 0` (note</span>
<span class="sd">       that this is only a quasi-metric if :math:`0 &lt; p &lt; 1`).</span>

<span class="sd">    3. ``Y = pdist(X, &#39;cityblock&#39;)``</span>

<span class="sd">       Computes the city block or Manhattan distance between the</span>
<span class="sd">       points.</span>

<span class="sd">    4. ``Y = pdist(X, &#39;seuclidean&#39;, V=None)``</span>

<span class="sd">       Computes the standardized Euclidean distance. The standardized</span>
<span class="sd">       Euclidean distance between two n-vectors ``u`` and ``v`` is</span>

<span class="sd">       .. math::</span>

<span class="sd">          \\sqrt{\\sum {(u_i-v_i)^2 / V[x_i]}}</span>


<span class="sd">       V is the variance vector; V[i] is the variance computed over all</span>
<span class="sd">       the i&#39;th components of the points.  If not passed, it is</span>
<span class="sd">       automatically computed.</span>

<span class="sd">    5. ``Y = pdist(X, &#39;sqeuclidean&#39;)``</span>

<span class="sd">       Computes the squared Euclidean distance :math:`\\|u-v\\|_2^2` between</span>
<span class="sd">       the vectors.</span>

<span class="sd">    6. ``Y = pdist(X, &#39;cosine&#39;)``</span>

<span class="sd">       Computes the cosine distance between vectors u and v,</span>

<span class="sd">       .. math::</span>

<span class="sd">          1 - \\frac{u \\cdot v}</span>
<span class="sd">                   {{\\|u\\|}_2 {\\|v\\|}_2}</span>

<span class="sd">       where :math:`\\|*\\|_2` is the 2-norm of its argument ``*``, and</span>
<span class="sd">       :math:`u \\cdot v` is the dot product of ``u`` and ``v``.</span>

<span class="sd">    7. ``Y = pdist(X, &#39;correlation&#39;)``</span>

<span class="sd">       Computes the correlation distance between vectors u and v. This is</span>

<span class="sd">       .. math::</span>

<span class="sd">          1 - \\frac{(u - \\bar{u}) \\cdot (v - \\bar{v})}</span>
<span class="sd">                   {{\\|(u - \\bar{u})\\|}_2 {\\|(v - \\bar{v})\\|}_2}</span>

<span class="sd">       where :math:`\\bar{v}` is the mean of the elements of vector v,</span>
<span class="sd">       and :math:`x \\cdot y` is the dot product of :math:`x` and :math:`y`.</span>

<span class="sd">    8. ``Y = pdist(X, &#39;hamming&#39;)``</span>

<span class="sd">       Computes the normalized Hamming distance, or the proportion of</span>
<span class="sd">       those vector elements between two n-vectors ``u`` and ``v``</span>
<span class="sd">       which disagree. To save memory, the matrix ``X`` can be of type</span>
<span class="sd">       boolean.</span>

<span class="sd">    9. ``Y = pdist(X, &#39;jaccard&#39;)``</span>

<span class="sd">       Computes the Jaccard distance between the points. Given two</span>
<span class="sd">       vectors, ``u`` and ``v``, the Jaccard distance is the</span>
<span class="sd">       proportion of those elements ``u[i]`` and ``v[i]`` that</span>
<span class="sd">       disagree.</span>

<span class="sd">    10. ``Y = pdist(X, &#39;jensenshannon&#39;)``</span>

<span class="sd">        Computes the Jensen-Shannon distance between two probability arrays.</span>
<span class="sd">        Given two probability vectors, :math:`p` and :math:`q`, the</span>
<span class="sd">        Jensen-Shannon distance is</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\sqrt{\\frac{D(p \\parallel m) + D(q \\parallel m)}{2}}</span>

<span class="sd">        where :math:`m` is the pointwise mean of :math:`p` and :math:`q`</span>
<span class="sd">        and :math:`D` is the Kullback-Leibler divergence.</span>

<span class="sd">    11. ``Y = pdist(X, &#39;chebyshev&#39;)``</span>

<span class="sd">        Computes the Chebyshev distance between the points. The</span>
<span class="sd">        Chebyshev distance between two n-vectors ``u`` and ``v`` is the</span>
<span class="sd">        maximum norm-1 distance between their respective elements. More</span>
<span class="sd">        precisely, the distance is given by</span>

<span class="sd">        .. math::</span>

<span class="sd">           d(u,v) = \\max_i {|u_i-v_i|}</span>

<span class="sd">    12. ``Y = pdist(X, &#39;canberra&#39;)``</span>

<span class="sd">        Computes the Canberra distance between the points. The</span>
<span class="sd">        Canberra distance between two points ``u`` and ``v`` is</span>

<span class="sd">        .. math::</span>

<span class="sd">          d(u,v) = \\sum_i \\frac{|u_i-v_i|}</span>
<span class="sd">                               {|u_i|+|v_i|}</span>


<span class="sd">    13. ``Y = pdist(X, &#39;braycurtis&#39;)``</span>

<span class="sd">        Computes the Bray-Curtis distance between the points. The</span>
<span class="sd">        Bray-Curtis distance between two points ``u`` and ``v`` is</span>


<span class="sd">        .. math::</span>

<span class="sd">             d(u,v) = \\frac{\\sum_i {|u_i-v_i|}}</span>
<span class="sd">                            {\\sum_i {|u_i+v_i|}}</span>

<span class="sd">    14. ``Y = pdist(X, &#39;mahalanobis&#39;, VI=None)``</span>

<span class="sd">        Computes the Mahalanobis distance between the points. The</span>
<span class="sd">        Mahalanobis distance between two points ``u`` and ``v`` is</span>
<span class="sd">        :math:`\\sqrt{(u-v)(1/V)(u-v)^T}` where :math:`(1/V)` (the ``VI``</span>
<span class="sd">        variable) is the inverse covariance. If ``VI`` is not None,</span>
<span class="sd">        ``VI`` will be used as the inverse covariance matrix.</span>

<span class="sd">    15. ``Y = pdist(X, &#39;yule&#39;)``</span>

<span class="sd">        Computes the Yule distance between each pair of boolean</span>
<span class="sd">        vectors. (see yule function documentation)</span>

<span class="sd">    16. ``Y = pdist(X, &#39;matching&#39;)``</span>

<span class="sd">        Synonym for &#39;hamming&#39;.</span>

<span class="sd">    17. ``Y = pdist(X, &#39;dice&#39;)``</span>

<span class="sd">        Computes the Dice distance between each pair of boolean</span>
<span class="sd">        vectors. (see dice function documentation)</span>

<span class="sd">    18. ``Y = pdist(X, &#39;kulczynski1&#39;)``</span>

<span class="sd">        Computes the kulczynski1 distance between each pair of</span>
<span class="sd">        boolean vectors. (see kulczynski1 function documentation)</span>

<span class="sd">        .. deprecated:: 1.15.0</span>
<span class="sd">           This metric is deprecated and will be removed in SciPy 1.17.0.</span>
<span class="sd">           Replace usage of ``pdist(X, &#39;kulczynski1&#39;)`` with</span>
<span class="sd">           ``1 / pdist(X, &#39;jaccard&#39;) - 1``.</span>

<span class="sd">    19. ``Y = pdist(X, &#39;rogerstanimoto&#39;)``</span>

<span class="sd">        Computes the Rogers-Tanimoto distance between each pair of</span>
<span class="sd">        boolean vectors. (see rogerstanimoto function documentation)</span>

<span class="sd">    20. ``Y = pdist(X, &#39;russellrao&#39;)``</span>

<span class="sd">        Computes the Russell-Rao distance between each pair of</span>
<span class="sd">        boolean vectors. (see russellrao function documentation)</span>

<span class="sd">    21. ``Y = pdist(X, &#39;sokalmichener&#39;)``</span>

<span class="sd">        Computes the Sokal-Michener distance between each pair of</span>
<span class="sd">        boolean vectors. (see sokalmichener function documentation)</span>

<span class="sd">        .. deprecated:: 1.15.0</span>
<span class="sd">           This metric is deprecated and will be removed in SciPy 1.17.0.</span>
<span class="sd">           Replace usage of ``pdist(X, &#39;sokalmichener&#39;)`` with</span>
<span class="sd">           ``pdist(X, &#39;rogerstanimoto&#39;)``.</span>

<span class="sd">    22. ``Y = pdist(X, &#39;sokalsneath&#39;)``</span>

<span class="sd">        Computes the Sokal-Sneath distance between each pair of</span>
<span class="sd">        boolean vectors. (see sokalsneath function documentation)</span>

<span class="sd">    23. ``Y = pdist(X, &#39;kulczynski1&#39;)``</span>

<span class="sd">        Computes the Kulczynski 1 distance between each pair of</span>
<span class="sd">        boolean vectors. (see kulczynski1 function documentation)</span>

<span class="sd">    24. ``Y = pdist(X, f)``</span>

<span class="sd">        Computes the distance between all pairs of vectors in X</span>
<span class="sd">        using the user supplied 2-arity function f. For example,</span>
<span class="sd">        Euclidean distance between the vectors could be computed</span>
<span class="sd">        as follows::</span>

<span class="sd">          dm = pdist(X, lambda u, v: np.sqrt(((u-v)**2).sum()))</span>

<span class="sd">        Note that you should avoid passing a reference to one of</span>
<span class="sd">        the distance functions defined in this library. For example,::</span>

<span class="sd">          dm = pdist(X, sokalsneath)</span>

<span class="sd">        would calculate the pair-wise distances between the vectors in</span>
<span class="sd">        X using the Python function sokalsneath. This would result in</span>
<span class="sd">        sokalsneath being called :math:`{n \\choose 2}` times, which</span>
<span class="sd">        is inefficient. Instead, the optimized C version is more</span>
<span class="sd">        efficient, and we call it using the following syntax.::</span>

<span class="sd">          dm = pdist(X, &#39;sokalsneath&#39;)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial.distance import pdist</span>

<span class="sd">    ``x`` is an array of five points in three-dimensional space.</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[2, 0, 2], [2, 2, 3], [-2, 4, 5], [0, 1, 9], [2, 2, 4]])</span>

<span class="sd">    ``pdist(x)`` with no additional arguments computes the 10 pairwise</span>
<span class="sd">    Euclidean distances:</span>

<span class="sd">    &gt;&gt;&gt; pdist(x)</span>
<span class="sd">    array([2.23606798, 6.40312424, 7.34846923, 2.82842712, 4.89897949,</span>
<span class="sd">           6.40312424, 1.        , 5.38516481, 4.58257569, 5.47722558])</span>

<span class="sd">    The following computes the pairwise Minkowski distances with ``p = 3.5``:</span>

<span class="sd">    &gt;&gt;&gt; pdist(x, metric=&#39;minkowski&#39;, p=3.5)</span>
<span class="sd">    array([2.04898923, 5.1154929 , 7.02700737, 2.43802731, 4.19042714,</span>
<span class="sd">           6.03956994, 1.        , 4.45128103, 4.10636143, 5.0619695 ])</span>

<span class="sd">    The pairwise city block or Manhattan distances:</span>

<span class="sd">    &gt;&gt;&gt; pdist(x, metric=&#39;cityblock&#39;)</span>
<span class="sd">    array([ 3., 11., 10.,  4.,  8.,  9.,  1.,  9.,  7.,  8.])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># You can also call this as:</span>
    <span class="c1">#     Y = pdist(X, &#39;test_abc&#39;)</span>
    <span class="c1"># where &#39;abc&#39; is the metric being tested.  This computes the distance</span>
    <span class="c1"># between all pairs of vectors in X using the distance metric &#39;abc&#39; but</span>
    <span class="c1"># with a more succinct, verifiable, but less efficient implementation.</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">_asarray_validated</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">sparse_ok</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">objects_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mask_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;A 2-dimensional array must be passed.&#39;</span><span class="p">)</span>

    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span>

    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">metric</span><span class="p">):</span>
        <span class="n">mstr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;UnknownCustomMetric&#39;</span><span class="p">)</span>
        <span class="n">metric_info</span> <span class="o">=</span> <span class="n">_METRIC_ALIAS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">mstr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">metric_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_validate_pdist_input</span><span class="p">(</span>
                <span class="n">X</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">metric_info</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_pdist_callable</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">mstr</span> <span class="o">=</span> <span class="n">metric</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">metric_info</span> <span class="o">=</span> <span class="n">_METRIC_ALIAS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">mstr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">metric_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pdist_fn</span> <span class="o">=</span> <span class="n">metric_info</span><span class="o">.</span><span class="n">pdist_func</span>
            <span class="k">return</span> <span class="n">pdist_fn</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;test_&quot;</span><span class="p">):</span>
            <span class="n">metric_info</span> <span class="o">=</span> <span class="n">_TEST_METRICS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">mstr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">metric_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unknown &quot;Test&quot; Distance Metric: </span><span class="si">{</span><span class="n">mstr</span><span class="p">[</span><span class="mi">5</span><span class="p">:]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_validate_pdist_input</span><span class="p">(</span>
                <span class="n">X</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">metric_info</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">_pdist_callable</span><span class="p">(</span>
                <span class="n">X</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric_info</span><span class="o">.</span><span class="n">dist_func</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unknown Distance Metric: </span><span class="si">{</span><span class="n">mstr</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;2nd argument metric must be a string identifier &#39;</span>
                        <span class="s1">&#39;or a function.&#39;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">squareform</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="s2">&quot;no&quot;</span><span class="p">,</span> <span class="n">checks</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a vector-form distance vector to a square-form distance</span>
<span class="sd">    matrix, and vice-versa.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : array_like</span>
<span class="sd">        Either a condensed or redundant distance matrix.</span>
<span class="sd">    force : str, optional</span>
<span class="sd">        As with MATLAB(TM), if force is equal to ``&#39;tovector&#39;`` or</span>
<span class="sd">        ``&#39;tomatrix&#39;``, the input will be treated as a distance matrix or</span>
<span class="sd">        distance vector respectively.</span>
<span class="sd">    checks : bool, optional</span>
<span class="sd">        If set to False, no checks will be made for matrix</span>
<span class="sd">        symmetry nor zero diagonals. This is useful if it is known that</span>
<span class="sd">        ``X - X.T1`` is small and ``diag(X)`` is close to zero.</span>
<span class="sd">        These values are ignored any way so they do not disrupt the</span>
<span class="sd">        squareform transformation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Y : ndarray</span>
<span class="sd">        If a condensed distance matrix is passed, a redundant one is</span>
<span class="sd">        returned, or if a redundant one is passed, a condensed distance</span>
<span class="sd">        matrix is returned.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    1. ``v = squareform(X)``</span>

<span class="sd">       Given a square n-by-n symmetric distance matrix ``X``,</span>
<span class="sd">       ``v = squareform(X)`` returns a ``n * (n-1) / 2``</span>
<span class="sd">       (i.e. binomial coefficient n choose 2) sized vector `v`</span>
<span class="sd">       where :math:`v[{n \\choose 2} - {n-i \\choose 2} + (j-i-1)]`</span>
<span class="sd">       is the distance between distinct points ``i`` and ``j``.</span>
<span class="sd">       If ``X`` is non-square or asymmetric, an error is raised.</span>

<span class="sd">    2. ``X = squareform(v)``</span>

<span class="sd">       Given a ``n * (n-1) / 2`` sized vector ``v``</span>
<span class="sd">       for some integer ``n &gt;= 1`` encoding distances as described,</span>
<span class="sd">       ``X = squareform(v)`` returns a n-by-n distance matrix ``X``.</span>
<span class="sd">       The ``X[i, j]`` and ``X[j, i]`` values are set to</span>
<span class="sd">       :math:`v[{n \\choose 2} - {n-i \\choose 2} + (j-i-1)]`</span>
<span class="sd">       and all diagonal elements are zero.</span>

<span class="sd">    In SciPy 0.19.0, ``squareform`` stopped casting all input types to</span>
<span class="sd">    float64, and started returning arrays of the same dtype as the input.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial.distance import pdist, squareform</span>

<span class="sd">    ``x`` is an array of five points in three-dimensional space.</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[2, 0, 2], [2, 2, 3], [-2, 4, 5], [0, 1, 9], [2, 2, 4]])</span>

<span class="sd">    ``pdist(x)`` computes the Euclidean distances between each pair of</span>
<span class="sd">    points in ``x``.  The distances are returned in a one-dimensional</span>
<span class="sd">    array with length ``5*(5 - 1)/2 = 10``.</span>

<span class="sd">    &gt;&gt;&gt; distvec = pdist(x)</span>
<span class="sd">    &gt;&gt;&gt; distvec</span>
<span class="sd">    array([2.23606798, 6.40312424, 7.34846923, 2.82842712, 4.89897949,</span>
<span class="sd">           6.40312424, 1.        , 5.38516481, 4.58257569, 5.47722558])</span>

<span class="sd">    ``squareform(distvec)`` returns the 5x5 distance matrix.</span>

<span class="sd">    &gt;&gt;&gt; m = squareform(distvec)</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    array([[0.        , 2.23606798, 6.40312424, 7.34846923, 2.82842712],</span>
<span class="sd">           [2.23606798, 0.        , 4.89897949, 6.40312424, 1.        ],</span>
<span class="sd">           [6.40312424, 4.89897949, 0.        , 5.38516481, 4.58257569],</span>
<span class="sd">           [7.34846923, 6.40312424, 5.38516481, 0.        , 5.47722558],</span>
<span class="sd">           [2.82842712, 1.        , 4.58257569, 5.47722558, 0.        ]])</span>

<span class="sd">    When given a square distance matrix ``m``, ``squareform(m)`` returns</span>
<span class="sd">    the one-dimensional condensed distance vector associated with the</span>
<span class="sd">    matrix.  In this case, we recover ``distvec``.</span>

<span class="sd">    &gt;&gt;&gt; squareform(m)</span>
<span class="sd">    array([2.23606798, 6.40312424, 7.34846923, 2.82842712, 4.89897949,</span>
<span class="sd">           6.40312424, 1.        , 5.38516481, 4.58257569, 5.47722558])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="n">force</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;tomatrix&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Forcing &#39;tomatrix&#39; but input X is not a &quot;</span>
                             <span class="s2">&quot;distance vector.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">force</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;tovector&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Forcing &#39;tovector&#39; but input X is not a &quot;</span>
                             <span class="s2">&quot;distance matrix.&quot;</span><span class="p">)</span>

    <span class="c1"># X = squareform(v)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Grab the closest value to the square root of the number</span>
        <span class="c1"># of elements times 2 to see if the number of elements</span>
        <span class="c1"># is indeed a binomial coefficient.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)))</span>

        <span class="c1"># Check that v is of valid dimensions.</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incompatible vector size. It must be a binomial &#39;</span>
                             <span class="s1">&#39;coefficient n choose 2 for some integer n &gt;= 2.&#39;</span><span class="p">)</span>

        <span class="c1"># Allocate memory for the distance matrix.</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Since the C code does not support striding using strides.</span>
        <span class="c1"># The dimensions are used instead.</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">_copy_array_if_base_present</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="c1"># Fill in the values of the distance matrix.</span>
        <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">to_squareform_from_vector_wrap</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>

        <span class="c1"># Return the distance matrix.</span>
        <span class="k">return</span> <span class="n">M</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The matrix argument must be square.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">checks</span><span class="p">:</span>
            <span class="n">is_valid_dm</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">throw</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>

        <span class="c1"># One-side of the dimensions is set here.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Create a vector.</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Since the C code does not support striding using strides.</span>
        <span class="c1"># The dimensions are used instead.</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">_copy_array_if_base_present</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="c1"># Convert the vector to squareform.</span>
        <span class="n">_distance_wrap</span><span class="o">.</span><span class="n">to_vector_from_squareform_wrap</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">v</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The first argument must be one or two dimensional &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;array. A </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="si">}</span><span class="s2">-dimensional array is not permitted&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">is_valid_dm</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">throw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="n">warning</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return True if input array is a valid distance matrix.</span>

<span class="sd">    Distance matrices must be 2-dimensional numpy arrays.</span>
<span class="sd">    They must have a zero-diagonal, and they must be symmetric.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    D : array_like</span>
<span class="sd">        The candidate object to test for validity.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        The distance matrix should be symmetric. `tol` is the maximum</span>
<span class="sd">        difference between entries ``ij`` and ``ji`` for the distance</span>
<span class="sd">        metric to be considered symmetric.</span>
<span class="sd">    throw : bool, optional</span>
<span class="sd">        An exception is thrown if the distance matrix passed is not valid.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        The name of the variable to checked. This is useful if</span>
<span class="sd">        throw is set to True so the offending variable can be identified</span>
<span class="sd">        in the exception message when an exception is thrown.</span>
<span class="sd">    warning : bool, optional</span>
<span class="sd">        Instead of throwing an exception, a warning message is</span>
<span class="sd">        raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    valid : bool</span>
<span class="sd">        True if the variable `D` passed is a valid distance matrix.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Small numerical differences in `D` and `D.T` and non-zeroness of</span>
<span class="sd">    the diagonal are ignored if they are within the tolerance specified</span>
<span class="sd">    by `tol`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial.distance import is_valid_dm</span>

<span class="sd">    This matrix is a valid distance matrix.</span>

<span class="sd">    &gt;&gt;&gt; d = np.array([[0.0, 1.1, 1.2, 1.3],</span>
<span class="sd">    ...               [1.1, 0.0, 1.0, 1.4],</span>
<span class="sd">    ...               [1.2, 1.0, 0.0, 1.5],</span>
<span class="sd">    ...               [1.3, 1.4, 1.5, 0.0]])</span>
<span class="sd">    &gt;&gt;&gt; is_valid_dm(d)</span>
<span class="sd">    True</span>

<span class="sd">    In the following examples, the input is not a valid distance matrix.</span>

<span class="sd">    Not square:</span>

<span class="sd">    &gt;&gt;&gt; is_valid_dm([[0, 2, 2], [2, 0, 2]])</span>
<span class="sd">    False</span>

<span class="sd">    Nonzero diagonal element:</span>

<span class="sd">    &gt;&gt;&gt; is_valid_dm([[0, 1, 1], [1, 2, 3], [1, 3, 0]])</span>
<span class="sd">    False</span>

<span class="sd">    Not symmetric:</span>

<span class="sd">    &gt;&gt;&gt; is_valid_dm([[0, 1, 3], [2, 0, 1], [3, 1, 0]])</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
    <span class="n">valid</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Distance matrix &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; must have shape=2 &quot;</span>
                                 <span class="s2">&quot;(i.e. be two-dimensional).&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Distance matrix must have shape=2 (i.e. &#39;</span>
                                 <span class="s1">&#39;be two-dimensional).&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tol</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">D</span> <span class="o">==</span> <span class="n">D</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Distance matrix &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; must be symmetric.&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Distance matrix must be symmetric.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Distance matrix &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; diagonal must be zero.&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Distance matrix diagonal must be zero.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">D</span> <span class="o">-</span> <span class="n">D</span><span class="o">.</span><span class="n">T</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Distance matrix </span><span class="se">\&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="se">\&#39;</span><span class="s1"> must be &#39;</span>
                                     <span class="sa">f</span><span class="s1">&#39;symmetric within tolerance </span><span class="si">{</span><span class="n">tol</span><span class="si">:</span><span class="s1">5.5f</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Distance matrix must be symmetric within &#39;</span>
                                     <span class="sa">f</span><span class="s1">&#39;tolerance </span><span class="si">{</span><span class="n">tol</span><span class="si">:</span><span class="s1">5.5f</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Distance matrix </span><span class="se">\&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="se">\&#39;</span><span class="s1"> diagonal must be &#39;</span>
                                     <span class="sa">f</span><span class="s1">&#39;close to zero within tolerance </span><span class="si">{</span><span class="n">tol</span><span class="si">:</span><span class="s1">5.5f</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s1">&#39;Distance matrix </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1"> diagonal must be close &#39;</span>
                                      <span class="s1">&#39;to zero within tolerance </span><span class="si">{:5.5f}</span><span class="s1">.&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">tol</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">throw</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">if</span> <span class="n">warning</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">valid</span>


<span class="k">def</span><span class="w"> </span><span class="nf">is_valid_y</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">warning</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">throw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return True if the input array is a valid condensed distance matrix.</span>

<span class="sd">    Condensed distance matrices must be 1-dimensional numpy arrays.</span>
<span class="sd">    Their length must be a binomial coefficient :math:`{n \\choose 2}`</span>
<span class="sd">    for some positive integer n.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : array_like</span>
<span class="sd">        The condensed distance matrix.</span>
<span class="sd">    warning : bool, optional</span>
<span class="sd">        Invokes a warning if the variable passed is not a valid</span>
<span class="sd">        condensed distance matrix. The warning message explains why</span>
<span class="sd">        the distance matrix is not valid.  `name` is used when</span>
<span class="sd">        referencing the offending variable.</span>
<span class="sd">    throw : bool, optional</span>
<span class="sd">        Throws an exception if the variable passed is not a valid</span>
<span class="sd">        condensed distance matrix.</span>
<span class="sd">    name : bool, optional</span>
<span class="sd">        Used when referencing the offending variable in the</span>
<span class="sd">        warning or exception message.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        True if the input array is a valid condensed distance matrix,</span>
<span class="sd">        False otherwise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial.distance import is_valid_y</span>

<span class="sd">    This vector is a valid condensed distance matrix.  The length is 6,</span>
<span class="sd">    which corresponds to ``n = 4``, since ``4*(4 - 1)/2`` is 6.</span>

<span class="sd">    &gt;&gt;&gt; v = [1.0, 1.2, 1.0, 0.5, 1.3, 0.9]</span>
<span class="sd">    &gt;&gt;&gt; is_valid_y(v)</span>
<span class="sd">    True</span>

<span class="sd">    An input vector with length, say, 7, is not a valid condensed distance</span>
<span class="sd">    matrix.</span>

<span class="sd">    &gt;&gt;&gt; is_valid_y([1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7])</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
    <span class="n">valid</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Condensed distance matrix &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; must &quot;</span>
                                 <span class="s2">&quot;have shape=1 (i.e. be one-dimensional).&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Condensed distance matrix must have shape=1 &#39;</span>
                                 <span class="s1">&#39;(i.e. be one-dimensional).&#39;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Length n of condensed distance matrix &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                                 <span class="s2">&quot;must be a binomial coefficient, i.e.&quot;</span>
                                 <span class="s2">&quot;there must be a k such that (k </span><span class="se">\\</span><span class="s2">choose 2)=n)!&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length n of condensed distance matrix must &#39;</span>
                                 <span class="s1">&#39;be a binomial coefficient, i.e. there must &#39;</span>
                                 <span class="s1">&#39;be a k such that (k </span><span class="se">\\</span><span class="s1">choose 2)=n)!&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">throw</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">if</span> <span class="n">warning</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">valid</span>


<span class="k">def</span><span class="w"> </span><span class="nf">num_obs_dm</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the number of original observations that correspond to a</span>
<span class="sd">    square, redundant distance matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d : array_like</span>
<span class="sd">        The target distance matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    num_obs_dm : int</span>
<span class="sd">        The number of observations in the redundant distance matrix.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Find the number of original observations corresponding</span>
<span class="sd">    to a square redundant distance matrix d.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial.distance import num_obs_dm</span>
<span class="sd">    &gt;&gt;&gt; d = [[0, 100, 200], [100, 0, 150], [200, 150, 0]]</span>
<span class="sd">    &gt;&gt;&gt; num_obs_dm(d)</span>
<span class="sd">    3</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
    <span class="n">is_valid_dm</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">throw</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">num_obs_y</span><span class="p">(</span><span class="n">Y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the number of original observations that correspond to a</span>
<span class="sd">    condensed distance matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Y : array_like</span>
<span class="sd">        Condensed distance matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    n : int</span>
<span class="sd">        The number of observations in the condensed distance matrix `Y`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Find the number of original observations corresponding to a</span>
<span class="sd">    condensed distance matrix Y.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; from scipy.spatial.distance import num_obs_y</span>
<span class="sd">    &gt;&gt;&gt; Y = [1, 2, 3.5, 7, 10, 4]</span>
<span class="sd">    &gt;&gt;&gt; num_obs_y(Y)</span>
<span class="sd">    4</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
    <span class="n">is_valid_y</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">throw</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of observations cannot be determined on &quot;</span>
                         <span class="s2">&quot;an empty distance matrix.&quot;</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid condensed distance matrix passed. Must be &quot;</span>
                         <span class="s2">&quot;some k where k=(n choose 2) for some n &gt;= 2.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_prepare_out_argument</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">expected_shape</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">expected_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">expected_shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Output array has incorrect shape.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">out</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">c_contiguous</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Output array must be C-contiguous.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Output array must be double type.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_pdist_callable</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">out_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">dm</span> <span class="o">=</span> <span class="n">_prepare_out_argument</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="n">out_size</span><span class="p">,))</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">dm</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">metric</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">dm</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_cdist_callable</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">mA</span> <span class="o">=</span> <span class="n">XA</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">mB</span> <span class="o">=</span> <span class="n">XB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dm</span> <span class="o">=</span> <span class="n">_prepare_out_argument</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="n">mA</span><span class="p">,</span> <span class="n">mB</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mA</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mB</span><span class="p">):</span>
            <span class="n">dm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">metric</span><span class="p">(</span><span class="n">XA</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">XB</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dm</span>


<div class="viewcode-block" id="cdist">
<a class="viewcode-back" href="../../../_foxesopt/problems/layout/geom_layouts/constraintscdist.html#foxes_opt.problems.layout.geom_layouts.constraints.cdist">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute distance between each pair of the two collections of inputs.</span>

<span class="sd">    See Notes for common calling conventions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    XA : array_like</span>
<span class="sd">        An :math:`m_A` by :math:`n` array of :math:`m_A`</span>
<span class="sd">        original observations in an :math:`n`-dimensional space.</span>
<span class="sd">        Inputs are converted to float type.</span>
<span class="sd">    XB : array_like</span>
<span class="sd">        An :math:`m_B` by :math:`n` array of :math:`m_B`</span>
<span class="sd">        original observations in an :math:`n`-dimensional space.</span>
<span class="sd">        Inputs are converted to float type.</span>
<span class="sd">    metric : str or callable, optional</span>
<span class="sd">        The distance metric to use. If a string, the distance function can be</span>
<span class="sd">        &#39;braycurtis&#39;, &#39;canberra&#39;, &#39;chebyshev&#39;, &#39;cityblock&#39;, &#39;correlation&#39;,</span>
<span class="sd">        &#39;cosine&#39;, &#39;dice&#39;, &#39;euclidean&#39;, &#39;hamming&#39;, &#39;jaccard&#39;, &#39;jensenshannon&#39;,</span>
<span class="sd">        &#39;kulczynski1&#39;, &#39;mahalanobis&#39;, &#39;matching&#39;, &#39;minkowski&#39;,</span>
<span class="sd">        &#39;rogerstanimoto&#39;, &#39;russellrao&#39;, &#39;seuclidean&#39;, &#39;sokalmichener&#39;,</span>
<span class="sd">        &#39;sokalsneath&#39;, &#39;sqeuclidean&#39;, &#39;yule&#39;.</span>
<span class="sd">    **kwargs : dict, optional</span>
<span class="sd">        Extra arguments to `metric`: refer to each metric documentation for a</span>
<span class="sd">        list of all possible arguments.</span>

<span class="sd">        Some possible arguments:</span>

<span class="sd">        p : scalar</span>
<span class="sd">        The p-norm to apply for Minkowski, weighted and unweighted.</span>
<span class="sd">        Default: 2.</span>

<span class="sd">        w : array_like</span>
<span class="sd">        The weight vector for metrics that support weights (e.g., Minkowski).</span>

<span class="sd">        V : array_like</span>
<span class="sd">        The variance vector for standardized Euclidean.</span>
<span class="sd">        Default: var(vstack([XA, XB]), axis=0, ddof=1)</span>

<span class="sd">        VI : array_like</span>
<span class="sd">        The inverse of the covariance matrix for Mahalanobis.</span>
<span class="sd">        Default: inv(cov(vstack([XA, XB].T))).T</span>

<span class="sd">        out : ndarray</span>
<span class="sd">        The output array</span>
<span class="sd">        If not None, the distance matrix Y is stored in this array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Y : ndarray</span>
<span class="sd">        A :math:`m_A` by :math:`m_B` distance matrix is returned.</span>
<span class="sd">        For each :math:`i` and :math:`j`, the metric</span>
<span class="sd">        ``dist(u=XA[i], v=XB[j])`` is computed and stored in the</span>
<span class="sd">        :math:`ij` th entry.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        An exception is thrown if `XA` and `XB` do not have</span>
<span class="sd">        the same number of columns.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The following are common calling conventions:</span>

<span class="sd">    1. ``Y = cdist(XA, XB, &#39;euclidean&#39;)``</span>

<span class="sd">       Computes the distance between :math:`m` points using</span>
<span class="sd">       Euclidean distance (2-norm) as the distance metric between the</span>
<span class="sd">       points. The points are arranged as :math:`m`</span>
<span class="sd">       :math:`n`-dimensional row vectors in the matrix X.</span>

<span class="sd">    2. ``Y = cdist(XA, XB, &#39;minkowski&#39;, p=2.)``</span>

<span class="sd">       Computes the distances using the Minkowski distance</span>
<span class="sd">       :math:`\\|u-v\\|_p` (:math:`p`-norm) where :math:`p &gt; 0` (note</span>
<span class="sd">       that this is only a quasi-metric if :math:`0 &lt; p &lt; 1`).</span>

<span class="sd">    3. ``Y = cdist(XA, XB, &#39;cityblock&#39;)``</span>

<span class="sd">       Computes the city block or Manhattan distance between the</span>
<span class="sd">       points.</span>

<span class="sd">    4. ``Y = cdist(XA, XB, &#39;seuclidean&#39;, V=None)``</span>

<span class="sd">       Computes the standardized Euclidean distance. The standardized</span>
<span class="sd">       Euclidean distance between two n-vectors ``u`` and ``v`` is</span>

<span class="sd">       .. math::</span>

<span class="sd">          \\sqrt{\\sum {(u_i-v_i)^2 / V[x_i]}}.</span>

<span class="sd">       V is the variance vector; V[i] is the variance computed over all</span>
<span class="sd">       the i&#39;th components of the points. If not passed, it is</span>
<span class="sd">       automatically computed.</span>

<span class="sd">    5. ``Y = cdist(XA, XB, &#39;sqeuclidean&#39;)``</span>

<span class="sd">       Computes the squared Euclidean distance :math:`\\|u-v\\|_2^2` between</span>
<span class="sd">       the vectors.</span>

<span class="sd">    6. ``Y = cdist(XA, XB, &#39;cosine&#39;)``</span>

<span class="sd">       Computes the cosine distance between vectors u and v,</span>

<span class="sd">       .. math::</span>

<span class="sd">          1 - \\frac{u \\cdot v}</span>
<span class="sd">                   {{\\|u\\|}_2 {\\|v\\|}_2}</span>

<span class="sd">       where :math:`\\|*\\|_2` is the 2-norm of its argument ``*``, and</span>
<span class="sd">       :math:`u \\cdot v` is the dot product of :math:`u` and :math:`v`.</span>

<span class="sd">    7. ``Y = cdist(XA, XB, &#39;correlation&#39;)``</span>

<span class="sd">       Computes the correlation distance between vectors u and v. This is</span>

<span class="sd">       .. math::</span>

<span class="sd">          1 - \\frac{(u - \\bar{u}) \\cdot (v - \\bar{v})}</span>
<span class="sd">                   {{\\|(u - \\bar{u})\\|}_2 {\\|(v - \\bar{v})\\|}_2}</span>

<span class="sd">       where :math:`\\bar{v}` is the mean of the elements of vector v,</span>
<span class="sd">       and :math:`x \\cdot y` is the dot product of :math:`x` and :math:`y`.</span>


<span class="sd">    8. ``Y = cdist(XA, XB, &#39;hamming&#39;)``</span>

<span class="sd">       Computes the normalized Hamming distance, or the proportion of</span>
<span class="sd">       those vector elements between two n-vectors ``u`` and ``v``</span>
<span class="sd">       which disagree. To save memory, the matrix ``X`` can be of type</span>
<span class="sd">       boolean.</span>

<span class="sd">    9. ``Y = cdist(XA, XB, &#39;jaccard&#39;)``</span>

<span class="sd">       Computes the Jaccard distance between the points. Given two</span>
<span class="sd">       vectors, ``u`` and ``v``, the Jaccard distance is the</span>
<span class="sd">       proportion of those elements ``u[i]`` and ``v[i]`` that</span>
<span class="sd">       disagree where at least one of them is non-zero.</span>

<span class="sd">    10. ``Y = cdist(XA, XB, &#39;jensenshannon&#39;)``</span>

<span class="sd">        Computes the Jensen-Shannon distance between two probability arrays.</span>
<span class="sd">        Given two probability vectors, :math:`p` and :math:`q`, the</span>
<span class="sd">        Jensen-Shannon distance is</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\sqrt{\\frac{D(p \\parallel m) + D(q \\parallel m)}{2}}</span>

<span class="sd">        where :math:`m` is the pointwise mean of :math:`p` and :math:`q`</span>
<span class="sd">        and :math:`D` is the Kullback-Leibler divergence.</span>

<span class="sd">    11. ``Y = cdist(XA, XB, &#39;chebyshev&#39;)``</span>

<span class="sd">        Computes the Chebyshev distance between the points. The</span>
<span class="sd">        Chebyshev distance between two n-vectors ``u`` and ``v`` is the</span>
<span class="sd">        maximum norm-1 distance between their respective elements. More</span>
<span class="sd">        precisely, the distance is given by</span>

<span class="sd">        .. math::</span>

<span class="sd">           d(u,v) = \\max_i {|u_i-v_i|}.</span>

<span class="sd">    12. ``Y = cdist(XA, XB, &#39;canberra&#39;)``</span>

<span class="sd">        Computes the Canberra distance between the points. The</span>
<span class="sd">        Canberra distance between two points ``u`` and ``v`` is</span>

<span class="sd">        .. math::</span>

<span class="sd">          d(u,v) = \\sum_i \\frac{|u_i-v_i|}</span>
<span class="sd">                               {|u_i|+|v_i|}.</span>

<span class="sd">    13. ``Y = cdist(XA, XB, &#39;braycurtis&#39;)``</span>

<span class="sd">        Computes the Bray-Curtis distance between the points. The</span>
<span class="sd">        Bray-Curtis distance between two points ``u`` and ``v`` is</span>


<span class="sd">        .. math::</span>

<span class="sd">             d(u,v) = \\frac{\\sum_i (|u_i-v_i|)}</span>
<span class="sd">                           {\\sum_i (|u_i+v_i|)}</span>

<span class="sd">    14. ``Y = cdist(XA, XB, &#39;mahalanobis&#39;, VI=None)``</span>

<span class="sd">        Computes the Mahalanobis distance between the points. The</span>
<span class="sd">        Mahalanobis distance between two points ``u`` and ``v`` is</span>
<span class="sd">        :math:`\\sqrt{(u-v)(1/V)(u-v)^T}` where :math:`(1/V)` (the ``VI``</span>
<span class="sd">        variable) is the inverse covariance. If ``VI`` is not None,</span>
<span class="sd">        ``VI`` will be used as the inverse covariance matrix.</span>

<span class="sd">    15. ``Y = cdist(XA, XB, &#39;yule&#39;)``</span>

<span class="sd">        Computes the Yule distance between the boolean</span>
<span class="sd">        vectors. (see `yule` function documentation)</span>

<span class="sd">    16. ``Y = cdist(XA, XB, &#39;matching&#39;)``</span>

<span class="sd">        Synonym for &#39;hamming&#39;.</span>

<span class="sd">    17. ``Y = cdist(XA, XB, &#39;dice&#39;)``</span>

<span class="sd">        Computes the Dice distance between the boolean vectors. (see</span>
<span class="sd">        `dice` function documentation)</span>

<span class="sd">    18. ``Y = cdist(XA, XB, &#39;kulczynski1&#39;)``</span>

<span class="sd">        Computes the kulczynski distance between the boolean</span>
<span class="sd">        vectors. (see `kulczynski1` function documentation)</span>

<span class="sd">        .. deprecated:: 1.15.0</span>
<span class="sd">           This metric is deprecated and will be removed in SciPy 1.17.0.</span>
<span class="sd">           Replace usage of ``cdist(XA, XB, &#39;kulczynski1&#39;)`` with</span>
<span class="sd">           ``1 / cdist(XA, XB, &#39;jaccard&#39;) - 1``.</span>

<span class="sd">    19. ``Y = cdist(XA, XB, &#39;rogerstanimoto&#39;)``</span>

<span class="sd">        Computes the Rogers-Tanimoto distance between the boolean</span>
<span class="sd">        vectors. (see `rogerstanimoto` function documentation)</span>

<span class="sd">    20. ``Y = cdist(XA, XB, &#39;russellrao&#39;)``</span>

<span class="sd">        Computes the Russell-Rao distance between the boolean</span>
<span class="sd">        vectors. (see `russellrao` function documentation)</span>

<span class="sd">    21. ``Y = cdist(XA, XB, &#39;sokalmichener&#39;)``</span>

<span class="sd">        Computes the Sokal-Michener distance between the boolean</span>
<span class="sd">        vectors. (see `sokalmichener` function documentation)</span>

<span class="sd">        .. deprecated:: 1.15.0</span>
<span class="sd">           This metric is deprecated and will be removed in SciPy 1.17.0.</span>
<span class="sd">           Replace usage of ``cdist(XA, XB, &#39;sokalmichener&#39;)`` with</span>
<span class="sd">           ``cdist(XA, XB, &#39;rogerstanimoto&#39;)``.</span>

<span class="sd">    22. ``Y = cdist(XA, XB, &#39;sokalsneath&#39;)``</span>

<span class="sd">        Computes the Sokal-Sneath distance between the vectors. (see</span>
<span class="sd">        `sokalsneath` function documentation)</span>

<span class="sd">    23. ``Y = cdist(XA, XB, f)``</span>

<span class="sd">        Computes the distance between all pairs of vectors in X</span>
<span class="sd">        using the user supplied 2-arity function f. For example,</span>
<span class="sd">        Euclidean distance between the vectors could be computed</span>
<span class="sd">        as follows::</span>

<span class="sd">          dm = cdist(XA, XB, lambda u, v: np.sqrt(((u-v)**2).sum()))</span>

<span class="sd">        Note that you should avoid passing a reference to one of</span>
<span class="sd">        the distance functions defined in this library. For example,::</span>

<span class="sd">          dm = cdist(XA, XB, sokalsneath)</span>

<span class="sd">        would calculate the pair-wise distances between the vectors in</span>
<span class="sd">        X using the Python function `sokalsneath`. This would result in</span>
<span class="sd">        sokalsneath being called :math:`{n \\choose 2}` times, which</span>
<span class="sd">        is inefficient. Instead, the optimized C version is more</span>
<span class="sd">        efficient, and we call it using the following syntax::</span>

<span class="sd">          dm = cdist(XA, XB, &#39;sokalsneath&#39;)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Find the Euclidean distances between four 2-D coordinates:</span>

<span class="sd">    &gt;&gt;&gt; from scipy.spatial import distance</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; coords = [(35.0456, -85.2672),</span>
<span class="sd">    ...           (35.1174, -89.9711),</span>
<span class="sd">    ...           (35.9728, -83.9422),</span>
<span class="sd">    ...           (36.1667, -86.7833)]</span>
<span class="sd">    &gt;&gt;&gt; distance.cdist(coords, coords, &#39;euclidean&#39;)</span>
<span class="sd">    array([[ 0.    ,  4.7044,  1.6172,  1.8856],</span>
<span class="sd">           [ 4.7044,  0.    ,  6.0893,  3.3561],</span>
<span class="sd">           [ 1.6172,  6.0893,  0.    ,  2.8477],</span>
<span class="sd">           [ 1.8856,  3.3561,  2.8477,  0.    ]])</span>


<span class="sd">    Find the Manhattan distance from a 3-D point to the corners of the unit</span>
<span class="sd">    cube:</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[0, 0, 0],</span>
<span class="sd">    ...               [0, 0, 1],</span>
<span class="sd">    ...               [0, 1, 0],</span>
<span class="sd">    ...               [0, 1, 1],</span>
<span class="sd">    ...               [1, 0, 0],</span>
<span class="sd">    ...               [1, 0, 1],</span>
<span class="sd">    ...               [1, 1, 0],</span>
<span class="sd">    ...               [1, 1, 1]])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([[ 0.1,  0.2,  0.4]])</span>
<span class="sd">    &gt;&gt;&gt; distance.cdist(a, b, &#39;cityblock&#39;)</span>
<span class="sd">    array([[ 0.7],</span>
<span class="sd">           [ 0.9],</span>
<span class="sd">           [ 1.3],</span>
<span class="sd">           [ 1.5],</span>
<span class="sd">           [ 1.5],</span>
<span class="sd">           [ 1.7],</span>
<span class="sd">           [ 2.1],</span>
<span class="sd">           [ 2.3]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># You can also call this as:</span>
    <span class="c1">#     Y = cdist(XA, XB, &#39;test_abc&#39;)</span>
    <span class="c1"># where &#39;abc&#39; is the metric being tested.  This computes the distance</span>
    <span class="c1"># between all pairs of vectors in XA and XB using the distance metric &#39;abc&#39;</span>
    <span class="c1"># but with a more succinct, verifiable, but less efficient implementation.</span>

    <span class="n">XA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">XA</span><span class="p">)</span>
    <span class="n">XB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">XB</span><span class="p">)</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">XA</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">sB</span> <span class="o">=</span> <span class="n">XB</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;XA must be a 2-dimensional array.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sB</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;XB must be a 2-dimensional array.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">sB</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;XA and XB must have the same number of columns &#39;</span>
                         <span class="s1">&#39;(i.e. feature dimension.)&#39;</span><span class="p">)</span>

    <span class="n">mA</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">mB</span> <span class="o">=</span> <span class="n">sB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">metric</span><span class="p">):</span>
        <span class="n">mstr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;Unknown&#39;</span><span class="p">)</span>
        <span class="n">metric_info</span> <span class="o">=</span> <span class="n">_METRIC_ALIAS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">mstr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">metric_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_validate_cdist_input</span><span class="p">(</span>
                <span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">mA</span><span class="p">,</span> <span class="n">mB</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">metric_info</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_cdist_callable</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">mstr</span> <span class="o">=</span> <span class="n">metric</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">metric_info</span> <span class="o">=</span> <span class="n">_METRIC_ALIAS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">mstr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">metric_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cdist_fn</span> <span class="o">=</span> <span class="n">metric_info</span><span class="o">.</span><span class="n">cdist_func</span>
            <span class="k">return</span> <span class="n">cdist_fn</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mstr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;test_&quot;</span><span class="p">):</span>
            <span class="n">metric_info</span> <span class="o">=</span> <span class="n">_TEST_METRICS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">mstr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">metric_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unknown &quot;Test&quot; Distance Metric: </span><span class="si">{</span><span class="n">mstr</span><span class="p">[</span><span class="mi">5</span><span class="p">:]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_validate_cdist_input</span><span class="p">(</span>
                <span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">mA</span><span class="p">,</span> <span class="n">mB</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">metric_info</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">_cdist_callable</span><span class="p">(</span>
                <span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric_info</span><span class="o">.</span><span class="n">dist_func</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unknown Distance Metric: </span><span class="si">{</span><span class="n">mstr</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;2nd argument metric must be a string identifier &#39;</span>
                        <span class="s1">&#39;or a function.&#39;</span><span class="p">)</span></div>

</code></pre></div>







  
  






                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  
  
  <div class="md-footer-meta md-typeset">
    
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-footer-copyright__highlight">
        &#169; Copyright 2024, Fraunhofer IWES.
        
    </div>
  
    Created using
    <a href="https://www.sphinx-doc.org/" target="_blank" rel="noopener">Sphinx</a>
    8.1.3.
     and
    <a href="https://github.com/jbms/sphinx-immaterial/" target="_blank" rel="noopener">Sphinx-Immaterial</a>
  
</div>
      
    </div>
    
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": [], "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
      
        <script src="../../../_static/sphinx_immaterial_theme.32136f45f91ae6956.min.js?v=a7a9472a"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
  </body>
</html>